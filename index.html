<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1">
<title>Tier Ticker üêæ</title>
<meta name="theme-color" content="#000000">

<!-- PWA MANIFEST -->
<link rel="manifest" href='data:application/manifest+json,{"name":"Tiere Z√§hlen Ult.","short_name":"TierTracker","start_url":".","display":"standalone","background_color":"#121212","theme_color":"#2196f3","icons":[{"src":"https://emojicdn.elk.sh/üêæ","sizes":"192x192","type":"image/png"}]}'>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- LEAFLET MAP CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>

<!-- Google Font: Fredoka (Rund & Verspielt) -->
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@500;700&display=swap" rel="stylesheet">

<!-- Handschrift-Font f√ºr die Karten -->
<link href="https://fonts.googleapis.com/css2?family=Caveat:wght@600&display=swap" rel="stylesheet">

<style>
/* =========================================
   1. VARIABLES & RESET
   ========================================= */
*, *::before, *::after { box-sizing: border-box; }

:root{
    --bg:#f0f2f5;
    --card:rgba(255, 255, 255, 0.85);
    --card-solid:#fff;
    --text:#1c1e21;
    --btn:#e4e6eb;
    --hover:#d8dadf;
    --accent:#2196f3;
    --accent-glow: rgba(33, 150, 243, 0.4);
    --warn-bg:#fff3cd; --warn-text:#856404;
    --err-bg:#f8d7da; --err-text:#721c24;
    --sub:#65676b; 
    --nav-height: 70px;
    --glass-border: 1px solid rgba(255, 255, 255, 0.6);
    --shadow: 0 4px 12px rgba(0,0,0,0.08);
--accent: #2196f3;
--paw-color: #ff9f43; 
}
/* === FIX: H√ÑSSLICHES VIERECK BEIM KLICKEN ENTFERNEN === */
* {
    /* Deaktiviert die graue/blaue Standard-Markierung auf Mobile */
    -webkit-tap-highlight-color: transparent;
    
    /* Verhindert, dass man Text/Icons aus Versehen markiert beim schnellen Tippen */
    -webkit-touch-callout: none; 
    user-select: none;
}

/* Text-Inputs m√ºssen ausw√§hlbar bleiben, sonst kann man nicht tippen! */
input, textarea {
    user-select: text !important;
    -webkit-user-select: text !important;
}
   
body.dark {
    /* TRUE OLED BLACK */
    --bg: #000000;
    --card: #000000;
    --card-solid: #000000;
    --text: #ffffff;
    --sub: #a0a0a0;
    --btn: #1a1a1a;
    --hover: #333333;
    --accent: #44a5ff; 
    --accent-glow: rgba(68, 165, 255, 0.4);
    --warn-bg: #1a1600; --warn-text: #ffd700;
    --err-bg: #2a0005; --err-text: #ff6b6b;
    --glass-border: 1px solid #333333;
    --shadow: none; 
--paw-color: #ffca65; 
}

body {
    font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
    background:var(--bg); 
    color:var(--text); 
    max-width:980px; 
    margin:auto; 
    padding:16px; 
    padding-bottom:calc(var(--nav-height) + 40px); 
    position:relative; 
    overflow-x:hidden; 
    transition: background 0.3s;
}

h1 { 
    margin-top: 5px; margin-bottom: 20px; 
    font-size: 1.8em; font-weight: 800; letter-spacing: -0.5px; 
    background: -webkit-linear-gradient(45deg, var(--text), var(--sub)); 
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; 
    width: fit-content;
}

/* =========================================
   2. UTILITIES & ANIMATIONS
   ========================================= */
.hidden { display: none !important; }
.fade-in { animation: fadeIn 0.3s forwards; }
@keyframes fadeIn { from{opacity:0;transform:translateY(10px)} to{opacity:1;transform:translateY(0)} }

/* Glass Panel Utility */
.glass-panel { 
    background: var(--card); backdrop-filter: blur(12px); 
    -webkit-backdrop-filter: blur(12px); border: var(--glass-border); 
    box-shadow: var(--shadow); 
}

/* Ripple Animation */
.ripple {
    position: absolute; border-radius: 50%; transform: scale(0);
    animation: ripple-anim 0.6s linear; background-color: rgba(255, 255, 255, 0.4);
    pointer-events: none;
}
@keyframes ripple-anim { to { transform: scale(4); opacity: 0; } }

/* Floating Particles */
.particle { 
    position: fixed; pointer-events: none; font-weight: bold; z-index: 9999; 
    animation: floatUp 0.8s ease-out forwards; font-size: 20px; 
    text-shadow: 0 2px 4px rgba(0,0,0,0.2); 
}
@keyframes floatUp { 
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; } 
    100% { transform: translate(-50%, -150px) scale(1.5); opacity: 0; } 
}

/* =========================================
   3. HEADER & NAVIGATION
   ========================================= */
/* Top Controls */
.header-controls { position:absolute; top:16px; right:16px; display:flex; gap:8px; z-index: 100; }

/* Der Info Button (Dezent, nicht "ausgew√§hlt") */
/* === HEADER BUTTONS (Repariert) === */

/* 1. Basis-Styling f√ºr ALLE Header-Buttons (Zahnrad & Info) */
.icon-btn-header {
    width: 40px;
    height: 40px;
    
    /* WICHTIG: Das macht sie rund! */
    border-radius: 50% !important; 
    border: none;
    
    display: flex;
    align-items: center;
    justify-content: center;
    
    font-size: 20px;
    cursor: pointer;
    transition: transform 0.2s;
    
    /* Standard-Look (f√ºr das Zahnrad): Grau */
    background: var(--btn);
    color: var(--text);
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* 2. Speziell f√ºr den Info-Button (Dezent) */
.icon-btn-header.info {
    /* Kein blauer Hintergrund mehr! Sondern neutral grau wie das Zahnrad */
    background: var(--btn);
    
    /* Nur das "i" leuchtet blau */
    color: var(--accent);
    
    /* Optional: Ein feiner farbiger Rand, damit er sich abhebt */
    border: 1px solid var(--accent-glow);
}

/* Klick-Effekt f√ºr beide */
.icon-btn-header:active {
    transform: scale(0.9);
}


/* List Header (Search & Add) */
.list-header { 
    display:flex; gap: 10px; margin-bottom:15px; position: relative; z-index: 5; 
}
.search-bar { 
    flex:1; width:auto; padding:12px 16px; border-radius:25px; border:none; 
    background:var(--card-solid); color:var(--text); font-size:15px; 
    box-shadow: var(--shadow); transition: box-shadow 0.2s; margin:0; 
}
.search-bar:focus { outline: 2px solid var(--accent); box-shadow: 0 4px 12px var(--accent-glow); }

/* Sticky Bottom Nav */
.bottom-nav {
    position: fixed; bottom: 20px; left: 20px; right: 20px; height: 65px;
    background: rgba(30, 30, 30, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255,255,255,0.1); border-radius: 35px;
    display: flex; justify-content: space-evenly; align-items: center;
    z-index: 9000; box-shadow: 0 10px 25px rgba(0,0,0,0.2); max-width: 500px; margin: 0 auto;
}
body:not(.dark) .bottom-nav { background: rgba(255, 255, 255, 0.85); border: 1px solid rgba(255,255,255,0.6); }
body.dark .bottom-nav { background: #000000; border-top: 1px solid #333; border-left: 1px solid #333; border-right: 1px solid #333; border-bottom: none; box-shadow: 0 -5px 20px rgba(255, 255, 255, 0.05); }

.nav-item { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--sub); cursor: pointer; transition: all 0.2s; font-size: 11px; background: none; border: none; padding: 0; position: relative; overflow: hidden; }
.nav-item .nav-icon { font-size: 22px; margin-bottom: 4px; transition: transform 0.2s; }
.nav-item.active { color: var(--accent); font-weight: 600; }
.nav-item.active .nav-icon { transform: translateY(-5px) scale(1.1); filter: drop-shadow(0 4px 5px var(--accent-glow)); }

/* Views Container */
.view-section { display: none; }
.view-section.active { display: block; animation: fadeIn 0.3s ease-out; }

/* =========================================
   4. INPUTS & BUTTONS
   ========================================= */
button { font-size:16px; padding:10px 16px; border-radius:14px; border:none; background:var(--btn); color:var(--text); cursor:pointer; transition: all 0.2s; font-weight: 600; }
button:active { transform: scale(0.96); }
button:hover { background:var(--hover); }

input,select,textarea { padding:12px; font-size:16px; border-radius:12px; border:1px solid var(--btn); background:var(--card-solid); color:var(--text); width: 100%; box-sizing: border-box; font-family: inherit; }
input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); }

/* Main Action Button (Blue Plus) */
.action-btn-main {
    background: var(--accent); color: white; width: 44px; height: 44px; border-radius: 14px;
    display: flex; align-items: center; justify-content: center; font-size: 20px; 
    box-shadow: 0 4px 10px var(--accent-glow); border: 2px solid var(--card-solid);
    transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.2s;
    cursor: pointer; position: relative; overflow: hidden;
}
.action-btn-main:active { transform: scale(0.90); }
.action-btn-main:hover { transform: scale(1.05); box-shadow: 0 6px 15px var(--accent-glow); }

/* Secondary Button (Edit) */
.action-btn-secondary {
    width: 44px; height: 44px; border-radius: 14px;
    background: var(--card-solid); color: var(--text); border: 1px solid var(--btn);
    display: flex; align-items: center; justify-content: center; font-size: 20px;
    cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); flex-shrink: 0;
}
.action-btn-secondary:active { transform: scale(0.9); }
.action-btn-secondary:hover { transform: scale(1.05); border-color: var(--accent); }

/* Large Sighting Button (New Header) */
.btn-sighting-large {
    flex: 1; display: flex; align-items: center; justify-content: center; gap: 8px;
    background: var(--accent); color: #fff; border: none; border-radius: 25px;
    font-weight: bold; font-size: 15px; box-shadow: var(--shadow); cursor: pointer;
    padding: 12px 16px; transition: transform 0.2s;
}
.btn-sighting-large:active { transform: scale(0.96); }

/* Floating View/Sort Buttons */
.float-btn {
    width: 44px; height: 44px; border-radius: 14px;
    background: var(--card); border: 1px solid var(--btn); color: var(--text);
    box-shadow: var(--shadow); display: flex; align-items: center; justify-content: center;
    font-size: 24px; cursor: pointer; transition: transform 0.2s;
}
.float-btn:active { transform: scale(0.9); }

/* Switch Toggle */
.switch { position: relative; display: inline-block; width: 50px; height: 28px; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--btn); transition: .4s; border-radius: 34px; }
.slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
input:checked + .slider { background-color: var(--accent); }
input:checked + .slider:before { transform: translateX(22px); }

/* =========================================
   5. LIST VIEW
   ========================================= */
.row {
    display: flex; align-items: center; gap: 6px; 
    background: var(--card); backdrop-filter: blur(10px);
    padding: 8px 8px; margin-bottom: 12px; border-radius: 20px; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.05); border: 1px solid rgba(255,255,255,0.4);
    transition: transform 0.2s, box-shadow 0.2s; height: auto; min-height: 70px;
}
.row:active { transform: scale(0.99); }
.row.is-active {
    border-color: var(--accent);
    background: linear-gradient(to right, var(--card), rgba(33, 150, 243, 0.05));
    box-shadow: 0 4px 12px var(--accent-glow);
}
body.dark .row.is-active { background: linear-gradient(to right, var(--card), rgba(100, 181, 246, 0.08)); border: 1px solid var(--accent); box-shadow: 0 0 10px rgba(68, 165, 255, 0.2); }
body.dark .row { border: 1px solid #222; background: #000000; }

.click-area-left {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    gap: 4px; cursor: pointer; border-radius: 16px; padding: 4px;
    transition: background 0.2s; min-width: 85px; max-width: 100px; text-align: center;
    position: relative; overflow: hidden;
}
.click-area-left:active { background: rgba(0,0,0,0.05); transform: scale(0.98); }
.click-area-left:hover .animal-icon { transform: scale(1.1) rotate(-5deg); border-color: var(--accent); box-shadow: 0 4px 12px var(--accent-glow); }

.animal-icon {
    font-size:26px; width:46px; height:46px; flex-shrink:0; 
    display:flex; align-items:center; justify-content:center; 
    overflow:hidden; border-radius:16px; cursor: pointer; 
    background: linear-gradient(135deg, var(--bg), var(--card-solid));
    border: 1px solid var(--btn); box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.animal-icon img { width:100%; height:100%; object-fit:cover; }

.name { 
    font-weight: 700; font-size: 13px; color: var(--text);
    white-space: normal; line-height: 1.2; word-wrap: break-word; margin-bottom: 2px;
}

/* === OPTION 2: GAMIFIED LEVEL BADGE === */
.count-badge {
    /* Gr√∂√üe & Layout */
    min-width: 38px;
    height: 34px;
    padding: 0 6px;
    
    display: flex; 
    align-items: center; 
    justify-content: center;
    
    /* Der Look: Verlauf + Neigung */
    background: linear-gradient(135deg, var(--accent), #9c27b0);
    color: white;
    
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.25); /* Innerer Glanz */
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    
    /* Die Box neigen (-10 Grad) */
    transform: skewX(-10deg);
    
    margin-left: auto; 
    margin-right: 5px;
    
    /* WICHTIG: Animation vorbereiten */
    transition: transform 0.2s;
}

/* WICHTIG: Die Zahl zur√ºck-neigen, damit sie gerade steht! */
.count-badge span {
    transform: skewX(10deg);
    display: inline-block;
    
    font-family: 'Fredoka', sans-serif; /* Deine Schrift */
    font-weight: 900;
    font-size: 15px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

/* Animation beim Hochz√§hlen (Pop Effekt) */
@keyframes countPop {
    0% { transform: skewX(-10deg) scale(1); }
    50% { transform: skewX(-10deg) scale(1.4); filter: brightness(1.3); box-shadow: 0 0 15px var(--accent); }
    100% { transform: skewX(-10deg) scale(1); }
}

.bump-effect {
    animation: countPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.fav-btn {
    background: none; border: none; font-size: 24px; color: var(--btn); 
    cursor: pointer; padding: 0 4px; margin-right: -4px; transition: transform 0.2s;
}
.fav-btn:active { transform: scale(1.3); }
.fav-btn.active { color: #ffb300; filter: drop-shadow(0 0 2px rgba(255,179,0,0.5)); }

/* Tags & Floating Controls */
.tag-scroll { display: flex; gap: 8px; overflow-x: auto; padding: 4px 4px 15px 4px; margin-bottom: 0px; scrollbar-width: none; mask-image: linear-gradient(to right, black 90%, transparent 100%); }
.tag-scroll::-webkit-scrollbar { display: none; }
.tag-pill { background: var(--btn); padding: 8px 16px; border-radius: 20px; font-size: 13px; white-space: nowrap; cursor: pointer; border: 1px solid transparent; transition: all 0.2s; font-weight: 500; }
.tag-pill.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px var(--accent-glow); transform: scale(1.05); }

.list-controls-floating {
    display: none; justify-content: flex-end; gap: 10px;
    margin-bottom: 10px; padding: 0 5px; animation: fadeIn 0.3s ease-out;
}
.list-controls-floating.visible { display: flex; }

/* List Toggle Btn */
.list-toggle-btn {
    width: 100%; max-width: 300px; margin: 10px auto 20px auto; padding: 10px 20px;
    background: var(--card); border: 1px solid var(--btn); border-radius: 30px;
    color: var(--sub); font-weight: 600; font-size: 14px; text-align: center;
    cursor: pointer; box-shadow: var(--shadow);
    display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s;
}
.list-toggle-btn:active { transform: scale(0.96); }
.list-toggle-btn.is-open { background: var(--btn); color: var(--text); border-color: var(--sub); }
.arrow-icon { display: inline-block; transition: transform 0.3s; }
.list-toggle-btn.is-open .arrow-icon { transform: rotate(180deg); }

/* =========================================
   6. GRID VIEW
   ========================================= */
.grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; padding-bottom: 20px; }
.grid-item { background: var(--card); border-radius: 20px; padding: 15px; display: flex; flex-direction: column; align-items: center; text-align: center; box-shadow: var(--shadow); position: relative; border: var(--glass-border); }
body.dark .grid-item { border: 1px solid #222; background: #000000; }

.grid-img-wrap { width: 80px; height: 80px; border-radius: 40px; overflow: hidden; margin-bottom: 10px; border: 4px solid var(--bg); box-shadow: 0 4px 8px rgba(0,0,0,0.1); cursor: pointer; display:flex; align-items:center; justify-content:center; font-size:40px; background:var(--btn); }
.grid-img-wrap img { width: 100%; height: 100%; object-fit: cover; }
.grid-name { font-weight: bold; font-size: 14px; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%; }
.grid-count { background: transparent; color: var(--accent); padding: 2px 8px; font-size: 16px; font-weight: bold; margin-bottom: 8px; }
.grid-actions { display: flex; gap: 8px; width: 100%; margin-top: 10px; }
.grid-btn { flex: 1; padding: 8px; border-radius: 10px; font-size: 16px; display:flex; align-items:center; justify-content:center; }

.grid-fav {
    position: absolute; top: 5px; right: 5px; font-size: 32px;
    color: var(--sub); cursor: pointer; z-index: 10;
    transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    text-shadow: 0 2px 5px rgba(0,0,0,0.2); 
}
body.dark .grid-fav { color: var(--accent); opacity: 0.8; }
.grid-fav.active { color: #ffb300 !important; opacity: 1; filter: drop-shadow(0 0 8px rgba(255, 179, 0, 0.6)); transform: scale(1.1); }
.grid-fav:active { transform: scale(0.8); }

/* =========================================
   7. MODALS & UI COMPONENTS
   ========================================= */
.modal { display: none; position: fixed; z-index: 9995; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); backdrop-filter: blur(4px); transition: opacity 0.3s; }
.modal-content {
    background-color: var(--card-solid); margin: 5% auto; padding: 25px; border-radius: 24px; width: 90%; max-width: 500px; position: relative; box-shadow: 0 20px 50px rgba(0,0,0,0.3);
    animation: zoomIn 0.2s ease-out; max-height: 85vh; overflow-y: auto;
}
@media (max-width: 600px) {
    .modal-content { margin: 0; position: absolute; bottom: 0; left: 0; width: 100%; max-width: 100%; border-radius: 24px 24px 0 0; animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1); padding-bottom: 40px; transform: translateZ(0); transition: transform 0.1s; }
}
@keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
@keyframes zoomIn { from { transform: scale(0.9); opacity:0; } to { transform: scale(1); opacity:1; } }

.close-btn { position: absolute; top: 15px; right: 20px; color: var(--sub); font-size: 24px; width:30px; height:30px; display:flex;align-items:center;justify-content:center; background:var(--btn); border-radius:50%; cursor: pointer; z-index:10; }
.sheet-handle { width: 50px; height: 6px; background: var(--btn); border-radius: 10px; margin: 0 auto 20px auto; cursor: grab; }

/* Lightbox */
#lightboxModal { display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); cursor: pointer; align-items: center; justify-content: center; animation: fadeIn 0.2s ease-out; }
#lightboxImg { max-width: 95%; max-height: 90vh; border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5); border: 2px solid #fff; transform: scale(0.9); transition: transform 0.3s; }
#lightboxModal.active #lightboxImg { transform: scale(1); }

/* Select Dropdown */
.modern-select {
    appearance: none; -webkit-appearance: none;
    background-color: var(--btn);
    background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23555%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
    background-repeat: no-repeat; background-position: right 8px top 50%; background-size: 10px auto;
    padding: 6px 24px 6px 12px; border-radius: 20px; border: 1px solid transparent;
    font-size: 12px; font-weight: 600; color: var(--sub); cursor: pointer;
    margin-right: 4px; max-width: 110px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; align-self: center; transition: all 0.2s;
}
.modern-select:focus { outline: none; border-color: var(--accent); background-color: var(--card-solid); box-shadow: 0 0 0 3px var(--accent-glow); }

/* Autocomplete */
.autocomplete-container { flex: 1; position: relative; }
.autocomplete-results { position: absolute; top: 100%; left: 0; right: 0; background: var(--card-solid); border: 1px solid var(--btn); z-index: 1000; display: none; max-height: 200px; overflow-y: auto; border-radius: 0 0 12px 12px; box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
.suggestion-item { padding: 12px; cursor: pointer; border-bottom: 1px solid var(--btn); font-size: 14px; }

/* =========================================
   8. ADMIN & TOOLS
   ========================================= */
.card-section { background:var(--card); padding:20px; border-radius:20px; box-shadow: var(--shadow); margin-bottom: 20px; border: var(--glass-border); }
.card-section h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.1em; border-bottom: 1px solid var(--btn); padding-bottom: 15px; display:flex; align-items:center; gap:10px; }
body.dark .card-section { border: 1px solid #222; background: #000000; }

.import-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
.import-actions button { height: 100%; padding: 15px; border-radius: 16px; }
.btn-merge { grid-column: span 2; background: var(--accent); color: white; }

.edit-tools { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0; }
.file-label { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 5px; background: var(--btn); padding: 15px; border-radius: 16px; cursor: pointer; font-size: 13px; font-weight: bold; }

/* Accordion */
.accordion-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding-bottom: 0 !important; border-bottom: none !important; margin-bottom: 0 !important; transition: opacity 0.2s; }
.accordion-header:active { opacity: 0.6; }
.acc-chevron { font-size: 14px; opacity: 0.5; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
.card-section.open .acc-chevron { transform: rotate(180deg); }
.accordion-content { display: grid; grid-template-rows: 0fr; transition: grid-template-rows 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease-out, padding 0.3s ease; opacity: 0; overflow: hidden; }
.card-section.open .accordion-content { grid-template-rows: 1fr; opacity: 1; margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--btn); }
.accordion-inner { min-height: 0; overflow: hidden; }

/* Backup Alerts */
.backup-alert { background: var(--warn-bg); color: var(--warn-text); padding: 12px 15px; border-radius: 12px; margin-bottom: 15px; font-size: 13px; display: flex; align-items: center; justify-content: space-between; animation: fadeIn 0.3s ease-out; border: 1px solid rgba(0,0,0,0.05); }
.backup-alert button { background: transparent; color: inherit; font-weight: bold; font-size: 16px; padding: 0 5px; width: auto; height: auto; border-radius: 4px; }
.backup-alert button:hover { background: rgba(0,0,0,0.1); }
/* === BACKUP BADGE MIT PFEIL ANIMATION === */

.header-warning-badge {
    background: var(--err-bg);
    color: var(--err-text);
    font-size: 11px;
    font-weight: bold;
    padding: 4px 10px;
    border-radius: 12px;
    
    /* Layout im Header */
    margin-right: 10px;
    margin-left: auto; /* Schiebt es nach rechts an den Titel */
    display: none;     /* Standardm√§√üig versteckt (JS schaltet es an) */
    
    border: 1px solid var(--err-text);
    position: relative; /* Wichtig Anker f√ºr den Pfeil */
    overflow: visible;  /* Damit der Pfeil au√üerhalb sichtbar ist */
}

/* Der rote Pfeil davor */
.header-warning-badge::before {
    content: '‚ûî'; 
    position: absolute;
    
    /* Vertikal zentrieren */
    top: 50%;
    margin-top: -1px; /* Mikrokosmos-Korrektur */
    transform: translateY(-50%);
    
    /* Farbe & Look */
    color: #ff4757; /* Knalliges Rot */
    font-size: 16px;
    font-weight: bold;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
    
    /* Animation einbinden */
    animation: pointArrow 0.8s ease-in-out infinite alternate;
}

/* Die Bewegung */
@keyframes pointArrow {
    0% {
        left: -20px; /* Nah dran */
    }
    100% {
        left: -26px; /* Weiter weg (Ausholen) */
    }
}
@keyframes pulseBadge { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

/* Trash */
.trash-row { transition: background 0.2s; }
.trash-row:hover { background: var(--btn); }

/* =========================================
   9. STATISTICS & DASHBOARD
   ========================================= */
.level-card { background: linear-gradient(135deg, #2196f3, #673ab7); color: white; padding: 25px; border-radius: 24px; margin-bottom: 20px; text-align: center; box-shadow: 0 10px 25px rgba(33, 150, 243, 0.3); position: relative; overflow: hidden; }
.level-card::before { content:''; position: absolute; top:-50%; left:-50%; width:200%; height:200%; background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 60%); pointer-events: none; }
.level-title { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.9; margin-bottom: 5px; }
.level-num { font-size: 42px; font-weight: 900; margin: 10px 0; text-shadow: 0 2px 10px rgba(0,0,0,0.3); }
.xp-bar-bg { background: rgba(0,0,0,0.25); height: 8px; border-radius: 4px; overflow: hidden; margin-top: 15px; }
.xp-bar-fill { background: #fff; height: 100%; width: 0%; transition: width 1s ease-out; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
.xp-text { font-size: 11px; margin-top: 6px; opacity: 0.9; }

.badge-grid { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
.badge { background: var(--btn); padding: 6px 10px; border-radius: 20px; font-size: 12px; display: flex; align-items: center; gap: 5px; opacity: 0.4; filter: grayscale(1); transition: all 0.3s; cursor: pointer; user-select: none; border: 1px solid transparent; }
.badge:active { transform: scale(0.95); }
.badge.earned { opacity: 1; filter: grayscale(0); background: rgba(33, 150, 243, 0.15); border-color: var(--accent); color: var(--accent); font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
.badge-icon { font-size: 16px; }

.stat-kpi-row { display:flex; gap:10px; justify-content:space-around; margin-bottom:15px; text-align:center; }
.stat-kpi { background:var(--card-solid); padding:10px; border-radius:12px; flex:1; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
.hbar-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 14px; }
.hbar-label { flex: 1; text-align: left; opacity: 0.9; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 0; }
.hbar-track { width: 40%; flex: none; background: var(--btn); height: 12px; border-radius: 6px; overflow: hidden; }
.hbar-fill { height: 100%; background: var(--accent); }
.hbar-val { font-size: 12px; width: 25px; text-align:right; font-weight:bold; flex:none; }

.chart-wrap { display: flex; align-items: flex-end; height: 140px; gap: 6px; padding-top: 25px; margin-top: 10px; }
.chart-col { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; height: 100%; }
.chart-bar { width: 100%; background: var(--accent); border-radius: 4px 4px 0 0; opacity: 0.9; min-height: 1px; background: linear-gradient(to top, var(--accent), #64b5f6); }
.chart-val { font-size: 10px; margin-bottom: 2px; }
.chart-label { font-size: 10px; margin-top: 4px; transform: rotate(-45deg); height: 20px; text-align: center; }


/* === LEVEL LISTE "ROADMAP" STYLE === */

.level-table { 
    width: 100%; border-collapse: separate; border-spacing: 0 4px; 
    font-size: 13px; text-align: left; 
}

.level-table tr {
    transition: transform 0.2s;
}

.level-table td { 
    padding: 8px 10px; 
    border-bottom: 1px solid rgba(0,0,0,0.05); /* Sehr dezent */
    background: var(--card-solid);
}

/* Runde Ecken f√ºr jede Zeile */
.level-table tr td:first-child { border-top-left-radius: 8px; border-bottom-left-radius: 8px; border-left-width: 4px; border-left-style: solid; }
.level-table tr td:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px; text-align: right; font-weight: bold; opacity: 0.7; }

/* === ZONEN FARBEN (Der "Hint") === */

/* Zone 1: Garten (Level 1-4) */
.row-garden td:first-child { border-left-color: #a8e063; }
.row-garden td { background: linear-gradient(90deg, rgba(168, 224, 99, 0.1), transparent); }

/* Zone 2: Wald (Level 5-8) */
.row-forest td:first-child { border-left-color: #134E5E; }
.row-forest td { background: linear-gradient(90deg, rgba(19, 78, 94, 0.1), transparent); }

/* Zone 3: Wasser (Level 9-12) */
.row-water td:first-child { border-left-color: #00c6ff; }
.row-water td { background: linear-gradient(90deg, rgba(0, 198, 255, 0.1), transparent); }

/* Zone 4: Savanne (Level 13-16) */
.row-savanna td:first-child { border-left-color: #f5af19; }
.row-savanna td { background: linear-gradient(90deg, rgba(245, 175, 25, 0.1), transparent); }

/* Zone 5: Legende (Level 17+) */
.row-legend td:first-child { border-left-color: #654ea3; }
.row-legend td { background: linear-gradient(90deg, rgba(101, 78, 163, 0.1), transparent); }

/* === AKTUELLES LEVEL === */
.level-table tr.current-level { 
    transform: scale(1.02); 
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    position: relative; z-index: 2;
}
.level-table tr.current-level td {
    background: var(--card-solid);
    border-bottom: 1px solid var(--accent);
    color: var(--accent);
    font-weight: 900;
}
.level-table tr.current-level td:first-child {
    border-left-color: var(--accent); /* Blaues Highlight f√ºr aktuelles Lvl */
    border-left-width: 6px;
}

.heatmap-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; max-width: 320px; margin: 10px auto; }
.heat-cell { aspect-ratio: 1; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 10px; color: transparent; background: var(--btn); }

/* Dashboard Hero */
.dashboard-hero {
    background: linear-gradient(135deg, var(--accent), #9c27b0); border-radius: 24px; padding: 20px;
    color: white; box-shadow: 0 10px 20px rgba(33, 150, 243, 0.3); margin-bottom: 20px;
    text-align: center; position: relative; overflow: hidden;
}
.dashboard-hero h2 { margin: 0; font-size: 32px; font-weight: 900; }
.dashboard-hero p { margin: 5px 0 0 0; opacity: 0.9; font-size: 14px; }
.hero-bg-icon { position: absolute; right: -20px; bottom: -20px; font-size: 100px; opacity: 0.2; pointer-events: none; }

/* Favoriten Karussell */
.fav-scroll-title { margin-left: 5px; font-size: 13px; font-weight:bold; color:var(--sub); margin-bottom:10px; text-transform:uppercase; letter-spacing:1px; }
.fav-scroll-container { display: flex; gap: 12px; overflow-x: auto; padding: 5px 5px 20px 5px; margin-bottom: 10px; scrollbar-width: none; }
.fav-scroll-container::-webkit-scrollbar { display: none; }

.fav-card {
    min-width: 95px; background: var(--card); border-radius: 18px; padding: 12px;
    display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px;
    box-shadow: 0 0 15px -4px var(--accent-glow); border: 1px solid rgba(255,255,255,0.1);
    cursor: pointer; transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); position: relative; overflow: hidden;
}
body.dark .fav-card { background: var(--card-solid); box-shadow: 0 0 15px -2px var(--accent-glow); }
.fav-card:active { transform: scale(0.96); box-shadow: 0 0 20px var(--accent); }

.fav-visual { width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; border-radius: 12px; background: var(--bg); margin: 0; overflow: hidden; font-size: 26px; border: 1px solid rgba(0,0,0,0.05); }
.fav-visual img { width: 100%; height: 100%; object-fit: cover; }
.fav-name { font-size: 11px; font-weight: 700; text-align: center; width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin: 0; opacity: 0.9; }
.fav-count { background: var(--btn); color: var(--accent); font-size: 10px; font-weight: 800; padding: 3px 8px; border-radius: 10px; margin: 0; }

/* Detail Modal Stats */
.stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
.stat-card { background: var(--bg); border-radius: 16px; padding: 12px; text-align: center; border: 1px solid var(--btn); box-shadow: 0 2px 5px rgba(0,0,0,0.02); }
.stat-value { font-size: 24px; font-weight: 900; color: var(--accent); margin: 5px 0; }
.stat-label { font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; }

.time-bar-container { display: flex; height: 24px; border-radius: 12px; overflow: hidden; margin-top: 10px; background: var(--btn); }
.time-segment { height: 100%; transition: width 0.5s ease-out; }
.ts-morgens { background: #FFC107; } .ts-mittags { background: #FF9800; } .ts-abends { background: #F44336; } .ts-nachts { background: #3F51B5; }
.time-legend { display: flex; justify-content: space-between; font-size: 10px; margin-top: 5px; opacity: 0.7; }

/* Map */
#map { height: 60vh; width: 100%; border-radius: 24px; z-index: 1; margin-bottom: 20px; border: 4px solid var(--card); box-shadow: var(--shadow); }

/* =========================================
   10. TOASTS & OTHER
   ========================================= */
.undo-toast {
    position: fixed; bottom: calc(var(--nav-height) + 20px); left: 50%; transform: translateX(-50%) translateY(100px);
    background: #323232; color: white; padding: 12px 20px; border-radius: 30px;
    display: flex; align-items: center; gap: 15px; z-index: 9998;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3); opacity: 0; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 90%; max-width: 400px; justify-content: space-between;
}
.undo-toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
.undo-btn { background: transparent; color: #64b5f6; font-weight: bold; text-transform: uppercase; font-size: 14px; padding: 5px 10px; margin: -5px -10px -5px 0; cursor: pointer; }
.error-toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: var(--err-bg); color: var(--err-text); padding: 12px 24px; border-radius: 50px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 9999; font-size: 14px; display: none; animation: fadeIn 0.3s; font-weight: bold; width: max-content; }

/* Top 3 Stats */
.top3-container { display: flex; flex-direction: column; gap: 8px; }
.top3-row { position: relative; display: flex; align-items: center; gap: 12px; padding: 10px 15px; background: var(--bg); border-radius: 16px; overflow: hidden; border: 1px solid var(--btn); }
.top3-bar { position: absolute; left: 0; top: 0; bottom: 0; background: var(--accent); opacity: 0.15; z-index: 0; transition: width 0.5s ease-out; }
.top3-medal { font-size: 22px; z-index: 1; width: 30px; text-align: center; }
.top3-img { width: 44px; height: 44px; border-radius: 50%; background: var(--card-solid); display: flex; align-items: center; justify-content: center; font-size: 24px; z-index: 1; border: 2px solid var(--card-solid); box-shadow: 0 2px 5px rgba(0,0,0,0.1); overflow: hidden; }
.top3-img img { width: 100%; height: 100%; object-fit: cover; }
.top3-info { flex: 1; z-index: 1; display: flex; justify-content: space-between; align-items: center; font-size: 14px; font-weight: bold; }
.top3-count { background: var(--card-solid); padding: 4px 10px; border-radius: 10px; font-size: 13px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }

/* Scroll Top Button */
#scrollTopBtn {
    position: fixed; bottom: 95px; right: 20px; width: 44px; height: 44px;
    background: var(--card-solid); border: 1px solid var(--btn); border-radius: 50%;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none; align-items: center; justify-content: center;
    font-size: 20px; cursor: pointer; z-index: 8000; transition: transform 0.2s, opacity 0.2s;
}
#scrollTopBtn:active { transform: scale(0.9); }
body.dark #scrollTopBtn { background: #222; border-color: #333; color: white; }

/* Today Modal List */
.today-list-container { display: flex; flex-direction: column; gap: 15px; padding: 10px 0; }
.today-row { display: flex; gap: 12px; animation: fadeIn 0.3s ease-out; }
.today-time-col { display: flex; flex-direction: column; align-items: center; min-width: 50px; padding-top: 5px; }
.today-time-text { font-size: 12px; font-weight: bold; color: var(--sub); background: var(--bg); padding: 2px 6px; border-radius: 8px; border: 1px solid var(--btn); }
.today-line { width: 2px; flex: 1; background: var(--btn); margin-top: 5px; border-radius: 2px; }
.today-bubble { flex: 1; background: var(--card); border: 1px solid var(--btn); border-radius: 0 16px 16px 16px; padding: 12px; position: relative; box-shadow: 0 2px 8px rgba(0,0,0,0.03); transition: transform 0.2s; }
.today-bubble:active { transform: scale(0.98); }
.today-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
.today-animal-name { font-weight: 800; font-size: 15px; color: var(--text); }
.today-details { font-size: 13px; color: var(--sub); line-height: 1.4; }
.today-tag { display: inline-block; background: rgba(33, 150, 243, 0.1); color: var(--accent); padding: 2px 8px; border-radius: 6px; font-size: 11px; font-weight: bold; margin-right: 5px; }

/* Compact View Overrides */
body.compact-view .row { padding: 4px 8px; min-height: 40px; }
body.compact-view .click-area-left { flex-direction: row; min-width: auto; gap: 8px; }
body.compact-view .animal-icon { width: 30px; height: 30px; font-size: 18px; }
body.compact-view .name { font-size: 14px; text-align: left; max-width: 150px; }
body.compact-view .action-btn-main, 
body.compact-view .action-btn-secondary { width: 32px; height: 32px; font-size: 16px; }


/* === BRANDING: TIER TICKER (Green Edition) === */
.app-brand {
    margin-top: 10px; 
    margin-bottom: 20px; 
    display: flex;
    align-items: center; 
    gap: 3px; 
    width: fit-content;
    background: none !important;
}

/* "Tier" - Der fette Teil */
.brand-tier {
    font-family: 'Fredoka', sans-serif;
    font-size: 34px; 
    font-weight: 700; 
    letter-spacing: 0.5px;
    background: -webkit-linear-gradient(45deg, var(--text), var(--sub));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

/* === SUCHEN UND ERSETZEN: L√∂sche den alten .brand-ticker Block komplett! === */

.brand-ticker {
    font-family: 'Fredoka', sans-serif;
    font-size: 34px; 
    font-weight: 700; 
    
    /* Layout */
    display: inline-block;
    transform: rotate(-2deg);
    
    /* 1. Der Verlauf (zum Testen Pink & Blau, damit man es sieht!) */
    background: linear-gradient(90deg, #ff00cc, #3333ff, #ff00cc);
    background-size: 200% auto;
    
    /* 2. Clipping: Hintergrund auf Textform zuschneiden */
    -webkit-background-clip: text;
    background-clip: text;
    
    /* 3. Textfarbe entfernen (WICHTIG!) */
    color: transparent;
    -webkit-text-fill-color: transparent !important;
    
    /* 4. Animation */
    animation: gradientFlow 5s linear infinite;
}

/* Diese Keyframes m√ºssen irgendwo ins CSS (z.B. direkt drunter) */
@keyframes gradientFlow {
    0% { background-position: 0% 50%; }
    100% { background-position: 200% 50%; }
}


/* DAS +1 ICON */
.brand-icon-pop {
    background: #228B22; 
    
    /* HIER DER FIX: Transparenz √ºberschreiben! */
    color: white !important;
    -webkit-text-fill-color: white !important; 
    -webkit-background-clip: border-box !important;
    
    font-size: 12px; 
    font-weight: 900;
    font-family: 'Fredoka', sans-serif;
    
    /* Layout */
    padding: 3px 7px;
    border-radius: 10px;
    display: inline-block; /* Wichtig f√ºr korrekte Darstellung */
    
    /* Positionierung */
    margin-left: 6px;
    margin-bottom: 22px; 
    
    transform: rotate(15deg);
    
    /* Gr√ºner Schatten */
    box-shadow: 0 3px 10px rgba(76, 209, 55, 0.4);
    border: 2px solid var(--bg); 
    
    animation: floatBubble 3s ease-in-out infinite;
}

@keyframes floatBubble {
    0%, 100% { transform: rotate(15deg) translateY(0); }
    50% { transform: rotate(10deg) translateY(-4px) scale(1.05); }
}

/* === BRANDING: SCHNEESPUR (SYNC VERSION) === */

.brand-tier { position: relative; }

/* Basis Pfote */

/* 1. Grundeinstellung (Standard / Light Mode) */

/* === FIX: EMOJI FARBE ERZWINGEN (Schatten-Trick) === */
.paw {
    position: absolute;
    font-size: 20px;
    z-index: 100;
    opacity: 0;
    pointer-events: none;

    /* 1. Das Original-Emoji unsichtbar machen */
    color: transparent !important;
    -webkit-text-fill-color: transparent !important;
    
    /* 2. Einen "Schatten" werfen, der so aussieht wie die Tatze */
    /* Syntax: x-offset y-offset blur color */
    text-shadow: 0 0 0 #ff9f43; /* Dein Orange */
}

/* Dark Mode: Hellerer Schatten */
body.dark .paw {
    text-shadow: 0 0 0 #ffca65; /* Helles Orange */
}

/* Pfote 1: Unten Rechts */
.paw-br {
    bottom: -12px; 
    right: -10px;
    /* Eigener Zeitplan, 8 Sekunden Loop */
    animation: pawCycle1 8s ease-out infinite;
}

/* Pfote 2: Oben Links */
.paw-tl {
    top: -16px;
    left: -4px;
    /* Eigener Zeitplan (Startet verz√∂gert im Keyframe selbst) */
    animation: pawCycle2 8s ease-out infinite;
}

/* ZEITPLAN 1 (Startet sofort) */
@keyframes pawCycle1 {
    0%   { opacity: 0; transform: scale(0.6) rotate(15deg); }
    10%  { opacity: 1; transform: scale(1) rotate(15deg); } /* Erscheint */
    75%  { opacity: 1; } /* Bleibt sichtbar bis kurz vor Ende */
    90%  { opacity: 0; } /* Verschwindet zusammen mit P2 */
    100% { opacity: 0; } /* Kurze Pause */
}

/* ZEITPLAN 2 (Wartet erst) */
@keyframes pawCycle2 {
    0%   { opacity: 0; transform: scale(0.6) rotate(-10deg); }
    30%  { opacity: 0; transform: scale(0.6) rotate(-10deg); } /* Wartet noch... */
    40%  { opacity: 1; transform: scale(1) rotate(-10deg); } /* Erscheint jetzt */
    75%  { opacity: 1; } /* Bleibt sichtbar (Sync mit P1) */
    90%  { opacity: 0; } /* Verschwindet (Sync mit P1) */
    100% { opacity: 0; } /* Kurze Pause */
}

/* === VERWALTUNG KARTEN GLOW (Gleichm√§√üig) === */
.card-section {
    background: var(--card);
    padding: 20px;
    border-radius: 24px;
    margin-bottom: 20px;
    
    /* Der Glow-Effekt: */
    border: 1px solid rgba(255, 255, 255, 0.1);
    
    /* √ÑNDERUNG: 0px Versatz in alle Richtungen, 20px Weichzeichner */
    box-shadow: 0 0 20px 2px var(--accent-glow);
    
    transition: all 0.3s ease;
}

/* Hover-Effekt: Der Glow wird intensiver */
.card-section:hover {
    box-shadow: 0 0 30px 5px var(--accent-glow);
    transform: scale(1.01); /* Minimaler Zoom wirkt edel */
    z-index: 1; /* Damit der Glow √ºber den anderen Karten liegt */
}

/* Utilities */
.hidden { display: none !important; }

/* === FIX: FADE IN ANIMATION === */
.fade-in { 
    /* WICHTIG: Element ist standardm√§√üig unsichtbar! */
    opacity: 0; 
    
    /* 'forwards' sorgt daf√ºr, dass es nach der Animation sichtbar (1) bleibt */
    animation: fadeIn 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; 
}

@keyframes fadeIn { 
    from { 
        opacity: 0; 
        transform: translateY(20px); /* Kommt leicht von unten */
    } 
    to { 
        opacity: 1; 
        transform: translateY(0); 
    } 
}

/* === MODAL STACKING === */
/* Ebene 1: Detailansicht */
#detailModal { z-index: 9990 !important; }

/* Ebene 2: Bearbeiten & Notiz (muss dar√ºber liegen) */
#iconModal, #noteModal { z-index: 9995 !important; }

/* Ebene 3: Lightbox & Toasts (ganz oben) */
#lightboxModal { z-index: 10000 !important; }
.undo-toast, .error-toast { z-index: 10001 !important; }

/* Animation f√ºr den Z√§hler */
@keyframes countPop {
    0% { transform: scale(1); }
    50% { transform: scale(1.4); color: #fff; background: var(--accent); }
    100% { transform: scale(1); }
}

.bump-effect {
    animation: countPop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}


input, select, textarea {
    padding: 12px 16px;
    font-size: 16px;
    border-radius: 16px; /* Runder */
    
    /* HIER NEU: Gef√ºllter Hintergrund statt nur Rahmen */
    background: rgba(0, 0, 0, 0.05); /* Leichter Grauschleier */
    border: 2px solid transparent; /* Rahmen vorbereiten */
    color: var(--text);
    width: 100%;
    box-sizing: border-box;
    font-family: inherit;
    font-weight: 600; /* Etwas fetter liest sich besser */
    
    transition: all 0.2s;
}

/* Fokus-Zustand: Hintergrund wird wei√ü, Rahmen farbig */
input:focus, select:focus, textarea:focus {
    outline: none;
    background: var(--card-solid);
    border-color: var(--accent);
    box-shadow: 0 4px 12px var(--accent-glow);
    transform: translateY(-1px);
}

/* Dark Mode Anpassung */
body.dark input, body.dark select, body.dark textarea {
    background: rgba(255, 255, 255, 0.1); /* Hellgrau auf Schwarz */
    color: white;
}
body.dark input:focus {
    background: #000; /* Zur√ºck zu Schwarz bei Fokus */
}
/* === START: NEON GLOW UPGRADE === */

/* 1. Der kleine Plus-Button in der Liste */
body.dark .action-btn-main {
    /* Hellerer Rand */
    border: 1px solid rgba(255,255,255,0.6);
    /* Doppelter Schatten */
    box-shadow: 
        0 0 10px rgba(33, 150, 243, 0.9),  /* Kern */
        0 0 25px rgba(33, 150, 243, 0.4);  /* Aura */
}

/* 2. Der gro√üe Sichtung-Button im Header */
body.dark .btn-sighting-large {
    /* Knalligerer Verlauf */
    background: linear-gradient(135deg, #44a5ff, #0069d9);
    
    /* Doppelter Schatten f√ºr maximalen Effekt */
    box-shadow: 
        0 0 20px rgba(33, 150, 243, 0.8),  /* Starker Kern */
        0 0 60px rgba(33, 150, 243, 0.5);  /* Weite Aura */
        
    /* Wei√üer Rand verst√§rkt den Kontrast */
    border: 1px solid rgba(255, 255, 255, 0.5);
    
    /* Optional: Macht den Text auch leicht leuchtend */
    text-shadow: 0 0 5px rgba(255,255,255,0.5);
}

/* Klick-Effekt: Kurz "abdunkeln" bzw. zusammenziehen */
body.dark .btn-sighting-large:active {
    transform: scale(0.96);
    box-shadow: 0 0 10px rgba(33, 150, 243, 1); /* Aura wird klein & hart */
}
/* === ENDE === */

/* === ONBOARDING / TUTORIAL STYLES (REPARIERT) === */

/* 1. Overlay (Transparent, dient nur als Klickschutz) */
#onboardingOverlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: transparent; 
    z-index: 9990; 
    display: none;
}

/* 2. Sprechblase (Ganz oben) */
.onboarding-box {
    position: fixed;
    background: var(--card-solid); color: var(--text);
    padding: 20px; border-radius: 20px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    z-index: 10005; /* H√∂her als Highlight */
    max-width: 300px; text-align: center; border: 2px solid var(--accent);
    top: 50%; left: 50%; transform: translate(-50%, -50%);
    animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.onboarding-box h3 { margin-top: 0; color: var(--accent); margin-bottom: 10px; }
.onboarding-box p { font-size: 14px; line-height: 1.5; opacity: 0.9; margin-bottom: 20px; }
.onboarding-btn-row { display: flex; justify-content: space-between; gap: 10px; }

/* 3. Das Highlight Element */
.tour-highlight {
    position: relative;
    z-index: 9999 !important;
    
    /* Der Schatten verdunkelt den Rest */
    box-shadow: 0 0 0 4000px rgba(0, 0, 0, 0.85), 0 0 15px var(--accent) !important;
    
    pointer-events: none;
    transition: box-shadow 0.3s ease-in-out;
    
    /* WICHTIG: KEIN Background setzen, damit der blaue Button blau bleibt! */
}

/* Spezial: Header Controls m√ºssen niedrig sein, damit der Schatten sie √ºberdeckt */
.header-controls {
    z-index: 10 !important; /* Niedriger als 9999 */
}

/* Spezial: Wenn ein runder Button gehighlighted wird */
.icon-btn-header.tour-highlight {
    border-radius: 50% !important;
    background: var(--card-solid) !important; /* Hier brauchen wir Hintergrund */
    z-index: 10000 !important; /* Muss √ºber den anderen liegen */
}

/* Spezial: Bottom Nav braucht Hintergrund (sonst durchsichtig) */
.bottom-nav.tour-highlight {
    position: fixed !important; bottom: 20px !important;
    background: var(--card-solid) !important; border-radius: 35px;
}

@keyframes popIn { from{transform:translate(-50%,-50%) scale(0.5);opacity:0} to{transform:translate(-50%,-50%) scale(1);opacity:1} }
/* === FIX: Stern Farbe angepasst (var(--sub) statt var(--btn)) === */
.fav-btn {
    background: none; 
    border: none; 
    font-size: 24px; 
    
    /* HIER DIE √ÑNDERUNG: */
    color: var(--sub); /* Hellgrau im Dark Mode, Dunkelgrau im Light Mode */
    
    cursor: pointer; 
    padding: 0 4px; 
    margin-right: -4px; 
    transition: transform 0.2s;
}

.fav-btn:active { transform: scale(1.3); }

/* Der gelbe Stern bleibt wie er ist */
.fav-btn.active { 
    color: #ffb300 !important; /* Wichtig, damit es das Grau √ºberschreibt */
    filter: drop-shadow(0 0 2px rgba(255,179,0,0.5)); 
}

/* === ULTIMATE LEVEL CARD UI (4 WELTEN) === */

.level-card {
    border-radius: 24px; padding: 25px 20px;
    color: white; text-align: center; position: relative; overflow: hidden;
    margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.15);
    transition: transform 0.2s;
    /* Standard Schatten */
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}
/* === LEVEL CARD THEMES (5 ZONES) === */

.level-card {
    /* Basis Layout */
    border-radius: 24px; padding: 25px 20px;
    color: white; text-align: center; position: relative; overflow: hidden;
    margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.15);
    transition: transform 0.2s;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}

/* ZONE 1: GARTEN (Hellgr√ºn/Gelb) */
.level-card.rank-garden {
    background: linear-gradient(135deg, #56ab2f, #a8e063);
    box-shadow: 0 10px 30px rgba(86, 171, 47, 0.3);
}

/* ZONE 2: WALD (Dunkelgr√ºn/Braun) */
.level-card.rank-forest {
    background: linear-gradient(135deg, #134E5E, #71B280);
    box-shadow: 0 10px 30px rgba(19, 78, 94, 0.4);
}

/* ZONE 3: WASSER (Tiefblau/T√ºrkis) */
.level-card.rank-water {
    background: linear-gradient(135deg, #00c6ff, #0072ff);
    box-shadow: 0 10px 30px rgba(0, 114, 255, 0.4);
}

/* ZONE 4: SAVANNE (Orange/Gold) */
.level-card.rank-savanna {
    background: linear-gradient(135deg, #f12711, #f5af19);
    box-shadow: 0 10px 30px rgba(245, 175, 25, 0.4);
    border: 1px solid rgba(255, 215, 0, 0.3);
}

/* ZONE 5: LEGENDE (Schwarz/Lila/Platin) */
.level-card.rank-legend {
    background: linear-gradient(135deg, #232526, #414345); /* Anthrazit */
    border: 1px solid rgba(255,255,255,0.3);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}
/* Legend√§rer Schimmer */
.level-card.rank-legend::before {
    content:''; position: absolute; top:-50%; left:-50%; width:200%; height:200%;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 60%);
    animation: floating 5s infinite;
}

/* Icons und Text */
.lvl-header {
    display: flex; justify-content: space-between; align-items: center;
    font-size: 11px; text-transform: uppercase; letter-spacing: 2px; opacity: 0.9;
    margin-bottom: 15px; font-weight: bold;
}
.lvl-icon-big {
    font-size: 60px; margin-bottom: 10px;
    filter: drop-shadow(0 5px 15px rgba(0,0,0,0.25));
    animation: floating 3s ease-in-out infinite;
}
.lvl-name {
    font-size: 30px; font-weight: 900; margin: 0; line-height: 1.1;
    text-shadow: 0 2px 10px rgba(0,0,0,0.2); font-family: 'Fredoka', sans-serif;
}

/* Progress Bar */
.lvl-progress-container { margin-top: 25px; position: relative; }
.lvl-bar-bg {
    background: rgba(0,0,0,0.25); height: 14px; border-radius: 20px; overflow: hidden;
    border: 1px solid rgba(255,255,255,0.1);
}
.lvl-bar-fill {
    height: 100%; border-radius: 20px; background: #fff;
    box-shadow: 0 0 20px rgba(255,255,255,0.7);
    position: relative; overflow: hidden; transition: width 1s ease-out;
}
.lvl-bar-fill::after {
    content: ''; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
    transform: translateX(-100%); animation: shimmer 2.5s infinite;
}
.lvl-stats-text {
    display: flex; justify-content: space-between; font-size: 11px; font-weight: bold; margin-top: 8px; opacity: 0.9;
}

@keyframes floating { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-8px)} }
@keyframes shimmer { 100% {transform: translateX(100%)} }


/* === JAHRES-SELECTOR (ZEITKAPSEL) === */

/* === JAHRES-SELECTOR (ZEITKAPSEL - GLOW UPDATE) === */
#statsYearSelect {
    /* 1. Reset */
    -webkit-appearance: none; appearance: none;
    
    /* 2. Look */
    background-color: var(--card-solid);
    color: var(--accent);
    font-size: 16px; font-weight: 900; letter-spacing: 0.5px;
    
    /* 3. Gr√∂√üe */
    padding: 10px 40px 10px 20px; /* Etwas kompakter */
    border: 2px solid var(--accent);
    border-radius: 30px;
    min-width: 120px;
    
    /* 4. DER NEUE GLOW: Gleichm√§√üig (0 0) und weich */
    box-shadow: 0 0 15px var(--accent-glow);
    
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    
    /* 5. Pfeil Icon */
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%232196f3'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 12px center;
    background-size: 20px;
}

#statsYearSelect:active {
    transform: scale(0.95);
    /* Beim Dr√ºcken wird der Glow etwas st√§rker */
    box-shadow: 0 0 25px var(--accent-glow);
}

/* Dark Mode Pfeil */
body.dark #statsYearSelect {
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2344a5ff'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
    background-color: #000;
}

/* === SPLIT VIEW LIST (PROFI LOOK) === */

/* Die Zeile ist nur noch der Container (kein Klick hier drauf!) */
.row {
    display: flex; align-items: stretch; /* Volle H√∂he */
    background: var(--card); backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.4);
    border-radius: 18px;
    margin-bottom: 10px;
    padding: 0; /* Wichtig: Padding weg, das machen die Kinder */
    overflow: hidden; /* F√ºr runde Ecken */
    min-height: 72px; /* Sch√∂ne H√∂he f√ºr Daumen */
    box-shadow: 0 4px 6px rgba(0,0,0,0.02);
    transition: transform 0.2s;
}
body.dark .row { border: 1px solid rgba(255,255,255,0.1); background: rgba(30,30,30,0.6); }

/* ZONE 1: HAUPTBEREICH (Details √∂ffnen) */
.row-main {
    flex: 1; /* Nimmt den meisten Platz */
    display: flex; align-items: center; gap: 12px;
    padding: 8px 0 8px 15px; /* Links Platz, Rechts offen */
    cursor: pointer;
    /* Klick-Feedback nur hier */
}
.row-main:active { background: rgba(0,0,0,0.05); }
body.dark .row-main:active { background: rgba(255,255,255,0.05); }

/* ZONE 2: DEAD ZONE (Sicherheitsabstand) */
.row-deadzone {
    width: 20px; /* Pufferzone */
    border-left: 1px solid rgba(0,0,0,0.03); /* Ganz feine Linie */
    /* Kein Pointer-Event, Klicks gehen ins Leere */
}

/* ZONE 3: MEN√ú (Optionen) */
.row-menu {
    width: 55px;
    display: flex; align-items: center; justify-content: center;
    font-size: 22px; color: var(--sub);
    cursor: pointer;
    border-left: 1px solid transparent;
}
.row-menu:active { background: rgba(0,0,0,0.05); color: var(--accent); }

/* Tacho-Effekt Klasse */
.odometer { font-variant-numeric: tabular-nums; transition: color 0.3s; }
.odometer.rolling { color: var(--accent); transform: scale(1.1); display:inline-block; }

/* === CONTEXT MENU (Das fehlende Popup) === */
.context-menu {
    position: fixed;
    background: var(--card-solid);
    border: 1px solid var(--btn);
    border-radius: 16px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 11000; /* Muss √úBER dem Modal (9990) liegen */
    overflow: hidden;
    min-width: 180px;
    animation: fadeIn 0.1s ease-out;
}
.context-item {
    padding: 14px 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    font-size: 15px;
    font-weight: 500;
    transition: background 0.1s;
    border-bottom: 1px solid rgba(0,0,0,0.03);
    color: var(--text);
}
.context-item:last-child { border-bottom: none; }
.context-item:active { background: var(--btn); }
.context-item.danger { color: var(--err-text); }
.context-backdrop {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 10999; background: transparent;
}

/* === MODERN LIST TOGGLE PILL === */
.list-toggle-btn {
    width: auto;
    max-width: fit-content;      /* Passt sich dem Text an */
    margin: 15px auto 20px auto; /* Abstand nach oben/unten */
    padding: 10px 25px;          /* Innenabstand */
    
    /* Glasmorphismus Look */
    background: var(--card);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    
    border-radius: 50px;         /* Pillen-Form */
    color: var(--text);
    
    font-weight: 700;
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    
    box-shadow: 0 5px 15px rgba(0,0,0,0.08); /* Sanfter Schatten */
    cursor: pointer;
    
    display: flex; align-items: center; justify-content: center; gap: 8px; 
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    z-index: 5;
}

/* Hover & Active Effekte */
.list-toggle-btn:active { transform: scale(0.94); }
.list-toggle-btn.is-open { 
    background: var(--btn); 
    border-color: transparent;
    box-shadow: inset 0 2px 6px rgba(0,0,0,0.05); /* Eingedr√ºckt wirken */
}

/* Pfeil Animation */
.arrow-icon { display: inline-block; transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); font-size: 14px; }
.list-toggle-btn.is-open .arrow-icon { transform: rotate(180deg); }

/* Dark Mode Anpassung */
body.dark .list-toggle-btn { border-color: rgba(255,255,255,0.1); background: rgba(30,30,30,0.6); }

/* === NEUE KPI BUBBLES === */
.kpi-grid {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 2 Spalten */
    gap: 12px;
    margin-bottom: 25px;
}

.kpi-bubble {
    background: var(--card);
    border-radius: 24px;
    padding: 15px;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    box-shadow: var(--shadow);
    border: 1px solid rgba(255,255,255,0.1);
    transition: transform 0.2s;
}

.kpi-bubble:active { transform: scale(0.96); }

/* Farb-Akzente f√ºr die KPIs */
.kpi-blue   { background: linear-gradient(145deg, rgba(33, 150, 243, 0.1), rgba(33, 150, 243, 0.02)); border-color: rgba(33, 150, 243, 0.3); }
.kpi-green  { background: linear-gradient(145deg, rgba(76, 209, 55, 0.1), rgba(76, 209, 55, 0.02)); border-color: rgba(76, 209, 55, 0.3); }
.kpi-orange { background: linear-gradient(145deg, rgba(255, 159, 67, 0.1), rgba(255, 159, 67, 0.02)); border-color: rgba(255, 159, 67, 0.3); }
.kpi-purple { background: linear-gradient(145deg, rgba(156, 39, 176, 0.1), rgba(156, 39, 176, 0.02)); border-color: rgba(156, 39, 176, 0.3); }

.kpi-icon { font-size: 24px; margin-bottom: 5px; opacity: 0.9; }
.kpi-val { font-size: 26px; font-weight: 900; color: var(--text); line-height: 1.1; }
.kpi-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; font-weight: bold; margin-top: 5px; }


/* === NEUE ROADMAP (LEVEL LISTE) === */
.roadmap-container {
    position: relative;
    padding-left: 20px; /* Platz f√ºr die Linie links */
    margin-top: 15px;
}

/* Die Linie im Hintergrund */
.roadmap-line {
    position: absolute;
    left: 10px; /* Mittig im Padding */
    top: 15px;
    bottom: 30px;
    width: 4px;
    background: var(--btn);
    border-radius: 2px;
    z-index: 0;
}

/* Ein einzelnes Level-Item (Bubble) */
.roadmap-item {
    position: relative;
    background: var(--card);
    border-radius: 20px;
    padding: 12px 15px;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    border: 1px solid transparent;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    z-index: 1; /* √úber der Linie */
}

/* Der Punkt auf der Linie */
.roadmap-dot {
    position: absolute;
    left: -24px; /* Auf der Linie positionieren */
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--sub);
    border: 3px solid var(--bg); /* Kleiner Abstand zur Linie */
    transition: all 0.3s;
}

/* Zone Colors f√ºr die Bubbles */
.rm-garden { border-left: 4px solid #a8e063; }
.rm-forest { border-left: 4px solid #134E5E; }
.rm-water  { border-left: 4px solid #00c6ff; }
.rm-savanna{ border-left: 4px solid #f5af19; }
.rm-legend { border-left: 4px solid #654ea3; }

/* Das AKTUELLE Level (Hervorgehoben) */
.roadmap-item.active {
    transform: scale(1.03) translateX(5px);
    background: var(--card-solid);
    box-shadow: 0 5px 20px rgba(0,0,0,0.1);
    border-color: var(--accent);
}
.roadmap-item.active .roadmap-dot {
    background: var(--accent);
    transform: scale(1.5);
    box-shadow: 0 0 10px var(--accent);
}
.roadmap-xp { margin-left: auto; font-weight: bold; font-size: 12px; opacity: 0.6; background: var(--btn); padding: 4px 8px; border-radius: 10px; }

/* === HEATMAP UPGRADE === */
.heatmap-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 300px; /* Passt gut auf Mobile */
    margin: 0 auto;
}

.heatmap-weekdays {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    width: 100%;
    margin-bottom: 5px;
    gap: 4px;
}

.heatmap-day-label {
    font-size: 10px;
    text-align: center;
    opacity: 0.5;
    font-weight: bold;
}

.heatmap-grid { 
    display: grid; 
    grid-template-columns: repeat(7, 1fr); 
    gap: 4px; 
    width: 100%;
}

.heat-cell { 
    aspect-ratio: 1; 
    border-radius: 6px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    font-size: 10px; 
    color: transparent; /* Zahl unsichtbar, au√üer bei Hover/Klick */
    background: var(--btn); 
    cursor: pointer;
    transition: transform 0.1s, border 0.1s;
}

.heat-cell:active, .heat-cell.selected {
    transform: scale(1.1);
    border: 1px solid var(--text);
    color: white !important; /* Zahl zeigen bei Klick */
    font-weight: bold;
    z-index: 2;
}

.heat-cell.is-today {
    border: 1px solid var(--accent);
}

.heatmap-info-line {
    margin-top: 10px;
    font-size: 12px;
    height: 16px; /* Reservierter Platz damit nichts springt */
    opacity: 0.8;
    text-align: center;
    font-weight: bold;
    color: var(--accent);
}

/* === FAVORITEN STORY STYLE (LARGE) === */
.fav-card {
    background: transparent !important;
    box-shadow: none !important;
    border: none !important;
    min-width: 95px; /* Container breiter machen f√ºr den gro√üen Kreis */
}

/* Der Kreis (Bild/Emoji) */
.fav-visual {
    /* GR√ñSSE HIER √ÑNDERN */
    width: 75px;   /* War vorher 60px */
    height: 75px;  /* War vorher 60px */
    font-size: 38px; /* Emoji auch vergr√∂√üern */
    
    border-radius: 50% !important;
    background: var(--card);
    
    /* Rand und Glow etwas verst√§rken */
    border: 3px solid var(--accent); 
    box-shadow: 0 0 20px rgba(33, 150, 243, 0.4);
    
    margin-bottom: 8px;
    position: relative; 
}

/* Der Z√§hler-Badge (Benachrichtigung) */
.fav-count {
    position: absolute;
    /* Positionierung leicht au√üerhalb des Kreises ("Notification Style") */
    top: 3px;
    right: 6px;
    
    background: var(--accent);
    color: white;
    
    /* SCHRIFT & GR√ñSSE */
    font-size: 13px;       /* War 10px -> jetzt deutlich lesbarer */
    font-weight: 900;      /* Extra fett */
    padding: 4px 9px;      /* Mehr "Fleisch" drumherum */
    min-width: 26px;       /* Mindestbreite, damit es sch√∂n rund bleibt */
    text-align: center;
    
    border-radius: 20px;   /* Pillenform */
    border: 3px solid var(--bg); /* Dickerer Rand zur Abgrenzung */
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    margin: 0;
    z-index: 2;
}

/* Name darunter */
.fav-name {
    font-size: 12px; /* Minimal gr√∂√üer f√ºr Balance */
    opacity: 0.9;
    font-weight: 700;
}


/* === TAG SCROLL MIT FADE-EFFEKT === */
.tag-scroll {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    padding: 4px 10px 15px 4px; /* Etwas Platz rechts */
    margin-bottom: 0px;
    
    /* Scrollbar verstecken */
    scrollbar-width: none; 
    -ms-overflow-style: none;
    
    /* Maske f√ºr weiches Ausblenden rechts */
    -webkit-mask-image: linear-gradient(to right, black 85%, transparent 100%);
    mask-image: linear-gradient(to right, black 85%, transparent 100%);
}
.tag-scroll::-webkit-scrollbar { display: none; }

/* Tag Button etwas aufh√ºbschen */
.tag-pill {
    background: var(--card); /* Transparenter */
    border: 1px solid rgba(255,255,255,0.1);
    backdrop-filter: blur(5px);
    padding: 8px 18px;
    border-radius: 20px;
    font-size: 13px;
    white-space: nowrap;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s;
}

.tag-pill.active {
    background: var(--accent);
    color: white;
    border-color: transparent;
    box-shadow: 0 4px 12px var(--accent-glow);
    transform: scale(1.05);
}

/* Farbige Hintergr√ºnde f√ºr Icons */
.animal-icon.color-0 { background: rgba(255, 99, 72, 0.15); border-color: rgba(255, 99, 72, 0.3); color: #ff6348; }
.animal-icon.color-1 { background: rgba(46, 213, 115, 0.15); border-color: rgba(46, 213, 115, 0.3); color: #2ed573; }
.animal-icon.color-2 { background: rgba(30, 144, 255, 0.15); border-color: rgba(30, 144, 255, 0.3); color: #1e90ff; }
.animal-icon.color-3 { background: rgba(255, 165, 2, 0.15);  border-color: rgba(255, 165, 2, 0.3);  color: #ffa502; }
.animal-icon.color-4 { background: rgba(162, 155, 254, 0.15); border-color: rgba(162, 155, 254, 0.3); color: #a29bfe; }
.animal-icon.color-5 { background: rgba(255, 71, 87, 0.15);  border-color: rgba(255, 71, 87, 0.3);  color: #ff4757; }

/* === SNEAK PEEK LIST STYLE === */
.sneak-peek-wrapper {
    position: relative;
    width: 100%;
    transition: all 0.5s ease-out; /* Weiches Aufklappen */
}

.sneak-peek-wrapper.collapsed {
    /* H√∂he f√ºr ca. 1.5 Zeilen (Eine Row ist ca 70-80px) */
    max-height: 140px; 
    overflow: hidden;
    
    /* Der Fade-Out Effekt (Maske) */
    -webkit-mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
    mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
}

/* Unsichtbare Klickfl√§che */
.sneak-peek-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 10;
    cursor: pointer;
    display: none; 
}
.sneak-peek-wrapper.collapsed .sneak-peek-overlay { display: block; }

/* Hinweis Text darunter */
.sneak-peek-hint {
    text-align: center; font-size: 12px; opacity: 0.5; margin-top: 5px; 
    transition: opacity 0.3s; pointer-events: none;
    font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
}
.sneak-peek-wrapper:not(.collapsed) + .sneak-peek-hint { opacity: 0; height: 0; margin: 0; }


/* === STATS DASHBOARD BUTTON (Verschoben) === */
.dashboard-hero-stats {
    background: linear-gradient(135deg, var(--accent), #9c27b0); 
    border-radius: 20px; 
    padding: 15px 20px;
    color: white; 
    box-shadow: 0 5px 15px rgba(33, 150, 243, 0.3); 
    margin-bottom: 25px;
    display: flex; align-items: center; justify-content: space-between;
    cursor: pointer;
    position: relative; overflow: hidden;
    transition: transform 0.2s;
}
.dashboard-hero-stats:active { transform: scale(0.98); }
.dashboard-hero-stats::before { content:'üêæ'; position: absolute; right: -10px; bottom: -15px; font-size: 90px; opacity: 0.15; pointer-events: none; }


/* === ULTIMATE STATS WIDGET === */
.stat-widget-wrapper {
    background: var(--card);
    border-radius: 24px;
    padding: 20px;
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    min-height: 250px; 
    position: relative;
    display: flex; flex-direction: column;
    margin-bottom: 20px;
    transition: height 0.3s;
}

/* Header & Dropdown */
.widget-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1);
    padding-bottom: 10px;
}
.widget-label { font-size: 11px; text-transform: uppercase; font-weight: bold; color: var(--sub); letter-spacing: 1px; }


.stat-selector {
    background: var(--btn);
    color: var(--accent);
    border: 1px solid var(--accent);
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 13px; font-weight: bold;
    outline: none; cursor: pointer;
    appearance: none; -webkit-appearance: none;
    text-align: center; width: auto; min-width: 120px;
}

/* Content Animation */
.stat-content { display: none; animation: slideInFade 0.3s ease-out; width: 100%; }
.stat-content.active { display: block; }
@keyframes slideInFade { from { opacity:0; transform:translateY(5px); } to { opacity:1; transform:translateY(0); } }

/* 1. HIGHLIGHTS GRID */
.grid-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.grid-item { background: rgba(255,255,255,0.03); padding: 12px; border-radius: 16px; display: flex; flex-direction: column; gap: 4px; }
.gi-label { font-size: 10px; opacity: 0.6; font-weight: bold; text-transform: uppercase; }
.gi-val { font-size: 15px; font-weight: bold; color: var(--text); }
.gi-icon { font-size: 18px; margin-bottom: 2px; }
.gi-highlight { color: #ff9f43; }

/* 2. TOP ORTE */
.loc-row { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
.loc-rank { width: 20px; height: 20px; background: var(--btn); color: var(--sub); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; }
.loc-rank.gold { background: #ffd700; color: #000; box-shadow: 0 0 8px rgba(255, 215, 0, 0.4); }
.loc-bar-bg { flex: 1; height: 6px; background: var(--btn); border-radius: 3px; overflow: hidden; }
.loc-bar-fill { height: 100%; background: var(--accent); border-radius: 3px; }

/* 3. RANKING LISTE */
.ranking-list { display: flex; flex-direction: column; gap: 8px; position: relative; max-height: 200px; overflow: hidden; }
.rank-row { display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 12px; background: rgba(255,255,255,0.02); opacity: 0.5; transform: scale(0.96); }
.rank-row.me { background: rgba(33, 150, 243, 0.1); border: 1px solid var(--accent); opacity: 1; transform: scale(1); box-shadow: 0 4px 15px rgba(0,0,0,0.1); z-index: 1; }
.r-pos { font-weight: 900; width: 30px; text-align: center; }
.r-name { flex: 1; font-weight: bold; font-size: 14px; }
.r-count { font-size: 12px; opacity: 0.8; background: var(--btn); padding: 2px 6px; border-radius: 4px; }

/* 4. MEMORY SWIPE */
.mem-scroll { display: flex; gap: 12px; overflow-x: auto; padding: 5px 5px 20px 5px; scrollbar-width: none; }
.mem-scroll::-webkit-scrollbar { display: none; }
.mem-card { min-width: 130px; max-width: 140px; background: var(--card-solid); border: 1px solid var(--btn); border-radius: 6px; padding: 10px; box-shadow: var(--shadow); flex-shrink: 0; transform: rotate(-1deg); display: flex; flex-direction: column; cursor: pointer; transition: transform 0.2s; }
.mem-card:active { transform: scale(0.98); }
.mem-date { font-size: 9px; color: var(--sub); margin-bottom: 5px; font-weight: bold; }
.mem-txt { font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.3; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 4; -webkit-box-orient: vertical; flex: 1; }

/* 5. TIMELINE */
.timeline { position: relative; padding-left: 15px; margin-top: 5px; }
.timeline::before { content:''; position:absolute; left:4px; top:5px; bottom:5px; width:2px; background:var(--btn); }
.tl-item { position: relative; margin-bottom: 15px; padding-left: 15px; }
.tl-dot { position: absolute; left: -16px; top: 3px; width: 10px; height: 10px; border-radius: 50%; background: var(--card); border: 2px solid var(--dot-col); }
.tl-head { font-size: 13px; font-weight: bold; color: var(--dot-col); }
.tl-sub { font-size: 11px; opacity: 0.6; }

/* 6. DNA */
.dna-track { height: 40px; background: var(--btn); border-radius: 8px; position: relative; overflow: hidden; margin-top:10px; }
.dna-mark { position: absolute; width: 2px; height: 100%; background: #42e695; opacity: 0.8; box-shadow: 0 0 4px #42e695; }
.dna-month { display: flex; justify-content: space-between; font-size: 9px; opacity: 0.4; margin-top: 4px; text-transform: uppercase; }

/* 7. RARITY */
.rarity-track { height: 6px; background: linear-gradient(to right, #a8e063, #2196f3, #9c27b0, #ff4757); border-radius: 3px; margin-top: 25px; position: relative; }
.rarity-cursor { position: absolute; top: -5px; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; transition: left 1s ease-out; }
.rarity-tag { background: var(--card); border: 1px solid var(--accent); color: var(--accent); padding: 2px 8px; border-radius: 8px; font-size: 10px; font-weight: bold; margin-bottom: 4px; white-space: nowrap; }
.rarity-tri { width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 6px solid var(--accent); }

/* === SEPARATER VERLAUF TOGGLE === */
.history-section {
    margin-top: 20px;
    margin-bottom: 20px;
}

/* Der Button/Balken */
.history-toggle-btn {
    width: 100%;
    padding: 16px 20px;
    background: var(--card); /* Gleicher Look wie Widget */
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 20px;
    
    display: flex; justify-content: space-between; align-items: center;
    
    font-size: 14px; font-weight: 800; color: var(--text);
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    transition: all 0.2s;
}

.history-toggle-btn:active {
    transform: scale(0.98);
    background: var(--btn);
}

.history-arrow {
    transition: transform 0.3s ease;
    opacity: 0.5; font-size: 12px;
}

/* Offener Zustand des Buttons */
.history-toggle-btn.open .history-arrow {
    transform: rotate(180deg);
    color: var(--accent); opacity: 1;
}

/* Der Container f√ºr die Liste (Animation) */
.history-container-wrapper {
    display: grid;
    grid-template-rows: 0fr;
    transition: grid-template-rows 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    opacity: 0;
}

.history-container-wrapper.open {
    grid-template-rows: 1fr;
    opacity: 1;
    margin-top: 10px;
}

.history-inner {
    overflow: hidden; /* Wichtig f√ºr die Animation */
    min-height: 0;
}

/* Scrollbereich innerhalb des offenen Containers */
.history-scroll-area {
    max-height: 400px;
    overflow-y: auto;
    padding-right: 5px;
    /* Optional: Eigener Hintergrund f√ºr die Liste */
    background: rgba(0,0,0,0.02);
    border-radius: 16px;
    padding: 10px;
    border: 1px solid rgba(255,255,255,0.05);
}

/* === 4. MEMORY LANE (PAPER STYLE) === */
.mem-scroll { 
    display: flex; 
    gap: 15px; /* Etwas mehr Abstand f√ºr die Rotation */
    overflow-x: auto; 
    padding: 10px 10px 25px 10px; /* Platz f√ºr Schatten unten */
    scrollbar-width: none; 
}
.mem-scroll::-webkit-scrollbar { display: none; }

.mem-card {
    min-width: 140px; 
    max-width: 150px;
    flex-shrink: 0;
    
    /* PAPIER LOOK (Helles Creme/Wei√ü) */
    background: #fffbf0 !important; 
    color: #2c2c2e !important; /* Dunkle Schrift f√ºr Kontrast */
    
    /* Kein Rand, daf√ºr Schatten f√ºr Tiefe */
    border: none !important;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3) !important;
    
    /* Form */
    border-radius: 4px; /* Nur leicht abgerundet wie echtes Papier */
    padding: 15px;
    
    display: flex; flex-direction: column;
    cursor: pointer;
    transition: transform 0.2s ease-out;
    position: relative;
    overflow: hidden;
}

/* Hover/Active Effekt */
.mem-card:active { transform: scale(0.96) rotate(0deg) !important; }

/* Datum wie ein Stempel */
.mem-date {
    font-size: 10px;
    color: #8a8a8a !important;
    font-weight: 800;
    text-transform: uppercase;
    margin-bottom: 8px;
    border-bottom: 1px dashed rgba(0,0,0,0.1);
    padding-bottom: 5px;
}

/* Text wie geschrieben */
.mem-txt {
    font-family: 'Courier New', Courier, monospace; /* Schreibmaschinen-Font */
    font-size: 12px;
    line-height: 1.4;
    font-weight: 600;
    
    overflow: hidden; 
    display: -webkit-box; 
    -webkit-line-clamp: 5; 
    -webkit-box-orient: vertical;
    flex: 1;
}

/* Deko-Element (Nadel/Tape oben) - Optional, sieht aber gut aus */
.mem-card::before {
    content: '';
    position: absolute; top: 0; left: 50%; transform: translateX(-50%);
    width: 30px; height: 8px;
    background: rgba(33, 150, 243, 0.3); /* Blaues "Tape" */
    opacity: 0.5;
}

/* === DNA BARCODE (Verbessert) === */
.dna-wrapper { margin-top: 10px; }
.dna-track { 
    height: 30px; background: rgba(255,255,255,0.05); border-radius: 4px; 
    position: relative; overflow: hidden; display: flex; align-items: center;
}
.dna-mark { 
    position: absolute; width: 3px; height: 100%; 
    background: #42e695; opacity: 0.8; box-shadow: 0 0 8px #42e695; 
}
/* Die Achse unten */
.dna-axis { 
    display: flex; justify-content: space-between; 
    margin-top: 6px; padding: 0 2px;
}
.dna-tick { 
    font-size: 9px; color: var(--sub); font-weight: bold; text-transform: uppercase; 
    width: 20px; text-align: center;
}
.dna-insight {
    text-align: center; font-size: 12px; color: var(--accent); 
    font-weight: bold; margin-top: 12px; background: rgba(33, 150, 243, 0.1);
    padding: 6px; border-radius: 8px;
}

/* === TIMELINE (Story Mode) === */
.timeline-container {
    position: relative; padding-left: 20px; margin-top: 10px;
}
.timeline-line {
    position: absolute; left: 7px; top: 5px; bottom: 5px; width: 2px; 
    background: linear-gradient(to bottom, var(--accent), var(--sub)); opacity: 0.3;
}
.tl-event {
    position: relative; margin-bottom: 20px;
}
.tl-icon-bubble {
    position: absolute; left: -20px; top: 0;
    width: 26px; height: 26px; border-radius: 50%;
    background: var(--card-solid); border: 2px solid var(--accent);
    display: flex; align-items: center; justify-content: center;
    font-size: 12px; z-index: 2;
}
.tl-content {
    background: rgba(255,255,255,0.03); padding: 10px; border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.05);
}
.tl-date { font-size: 10px; opacity: 0.6; font-weight: bold; text-transform: uppercase; margin-bottom: 2px; }
.tl-title { font-size: 13px; font-weight: bold; margin-bottom: 2px; color: var(--text); }
.tl-desc { font-size: 12px; opacity: 0.8; line-height: 1.3; }

/* === RARITY SCALE (Beschriftet) === */
.rarity-wrapper { margin-top: 25px; padding: 0 10px; }
.rarity-scale-line {
    height: 6px; border-radius: 3px; position: relative;
    background: linear-gradient(to right, #4cd137 0%, #00a8ff 50%, #e84118 100%);
}
.rarity-pointer {
    position: absolute; top: -35px; transform: translateX(-50%);
    display: flex; flex-direction: column; align-items: center;
    transition: left 1s ease-out;
}
.rarity-flag {
    background: var(--card-solid); color: var(--text);
    border: 2px solid var(--text); padding: 4px 10px; border-radius: 12px;
    font-size: 11px; font-weight: 900; white-space: nowrap;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3); margin-bottom: 6px;
}
.rarity-triangle {
    width: 0; height: 0; 
    border-left: 6px solid transparent; border-right: 6px solid transparent;
    border-top: 8px solid var(--text);
}
.rarity-labels {
    display: flex; justify-content: space-between; margin-top: 8px;
    font-size: 10px; font-weight: bold; opacity: 0.5; text-transform: uppercase;
}

/* === DROPDOWN: FINAL FIX (NO REPEAT) === */
.stat-selector {
    /* 1. Reset */
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    outline: none;

    /* 2. Basis-Design */
    background-color: var(--btn);
    color: var(--accent);
    border: 1px solid var(--accent);
    border-radius: 15px;
    font-size: 13px; 
    font-weight: bold;
    cursor: pointer;
    min-width: 130px;
    text-align: center;
    text-align-last: center;
    padding: 6px 32px 6px 12px;

    /* 3. DAS BILD (Drei Punkte) */
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%232196f3'%3e%3cpath d='M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z'/%3e%3c/svg%3e");
    
    /* 4. DER FIX (Erzwungen) */
    background-repeat: no-repeat !important;
    background-position: right 8px center !important;
    background-size: 20px !important;
}

/* Dark Mode Bild austauschen */
body.dark .stat-selector {
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%232196f3'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
    
    /* Sicherheitshalber hier auch nicht wiederholen */
    background-repeat: no-repeat !important;
}

/* Der Container f√ºr den Header */
.detail-header-wrapper {
    position: relative;
    border-radius: 20px 20px 0 0;
    margin: -25px -25px 20px -25px; /* Negativer Margin zieht es an den Rand */
    padding: 30px 25px 20px 25px;
    overflow: hidden;
    border-bottom: 1px solid rgba(255,255,255,0.1);
}

/* Das unscharfe Hintergrundbild */
.detail-bg-blur {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background-size: cover; background-position: center;
    filter: blur(20px) brightness(0.4);
    opacity: 0.6; z-index: 0;
}

/* Der Inhalt (√ºber dem Blur) */
.detail-header-content {
    position: relative; z-index: 1;
    display: flex; align-items: center; gap: 15px;
}

/* Update f√ºr .card-section und .row und .glass-panel */
.card-section, .row, .stat-widget-wrapper, .modal-content {
    /* 1. Hintergrund etwas dunkler f√ºr Kontrast */
    background: rgba(28, 28, 30, 0.6) !important;
    
    /* 2. Der Blur Effekt (Milchglas) */
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    
    /* 3. DER TRICK: Inneres Licht oben + Schatten unten */
    border: 1px solid rgba(255, 255, 255, 0.08) !important; /* Dunklerer Rand */
    box-shadow: 
        0 4px 20px rgba(0,0,0,0.4),       /* Tiefer Schatten */
        inset 0 1px 0 rgba(255,255,255,0.15); /* Lichtkante oben innen! */
        
    border-radius: 22px !important; /* Etwas runder wirkt freundlicher */
}

/* === PREMIUM GLASS GRID ITEM === */
.grid-item {
    /* 1. Hintergrund & Blur (Dark Glass) */
    background: rgba(28, 28, 30, 0.6) !important;
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    
    /* 2. Die Premium Kanten (Licht oben, Schatten unten) */
    border: 1px solid rgba(255, 255, 255, 0.08) !important;
    border-radius: 24px !important; /* Sch√∂n rund */
    
    /* Der Trick: Inset Shadow oben simuliert Lichtkante */
    box-shadow: 
        0 10px 25px rgba(0,0,0,0.3),         /* Tiefer Schatten au√üen */
        inset 0 1px 0 rgba(255,255,255,0.15) !important; /* Helle Kante innen */

    /* Layout (Bleibt gleich) */
    padding: 15px; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    text-align: center; 
    position: relative; 
    
    /* Animation */
    transition: transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow 0.2s;
}

/* Klick-Effekt: Kachel dr√ºckt sich rein */
.grid-item:active { 
    transform: scale(0.96); 
    /* Schatten wird kleiner beim Dr√ºcken */
    box-shadow: 
        0 2px 8px rgba(0,0,0,0.2), 
        inset 0 1px 0 rgba(255,255,255,0.1) !important; 
}

/* Optional: Bild-Kreis auch etwas aufwerten */
.grid-img-wrap {
    box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Mehr Tiefe f√ºr das Bild */
    border: 2px solid rgba(255,255,255,0.1); /* Dezentere Umrandung */
}



/* Premium Glass look Ende */

/* === AMBIENT BACKGROUND GLOW === */
body::before, body::after {
    content: '';
    position: fixed;
    width: 300px; height: 300px;
    border-radius: 50%;
    filter: blur(80px);
    opacity: 0.15; /* Sehr dezent */
    z-index: -1; /* Hinter allem */
    animation: ambientFloat 10s infinite alternate;
}

/* Oben Links: Blau */
body::before {
    top: -100px; left: -50px;
    background: var(--accent);
}

/* Unten Rechts: Lila/Orange */
body::after {
    bottom: -50px; right: -50px;
    background: #9c27b0;
    animation-delay: -5s;
}

@keyframes ambientFloat {
    0% { transform: translate(0, 0) scale(1); }
    100% { transform: translate(30px, 50px) scale(1.2); }
}

/* === SHIMMER EFFEKT (PREMIUM GLANZ) === */

/* 1. Basis-Update f√ºr die Zeile (Wichtig!) */
.row {
    position: relative; /* Anker f√ºr den Effekt */
    overflow: hidden;   /* Damit der Glanz nicht √ºber den Rand geht */
}

/* 2. Der Lichtstreifen (Pseudo-Element) */
.row::after {
    content: '';
    position: absolute;
    top: 0; 
    left: -100%; /* Startet au√üerhalb links */
    width: 80%;  /* Breite des Lichtstreifens */
    height: 100%;
    
    /* Der Verlauf: Transparent -> Helles Wei√ü (ganz zart) -> Transparent */
    background: linear-gradient(
        to right, 
        transparent 0%, 
        rgba(255, 255, 255, 0.22) 50%, 
        transparent 100%
    );
    
    /* Neigung f√ºr Dynamik */
    transform: skewX(-25deg);
    
    /* WICHTIG: Klicks sollen durchgehen! */
    pointer-events: none; 
    
    /* Die Animation */
    animation: shimmerLoop 30s infinite; 
    z-index: 5; /* √úber dem Hintergrund, unter dem Text */
}

/* 3. Die Bewegung */
@keyframes shimmerLoop {
    0% { left: -100%; }
    20% { left: 200%; } /* Huschtdr√ºber */
    100% { left: 200%; } /* Lange Pause bis zur 30. Sekunde */
}

/* === SHIMMER F√úR GRID KACHELN === */

/* 1. Basis-Update (Wichtig damit der Glanz nicht rausragt) */
.grid-item {
    position: relative !important;
    overflow: hidden !important;
}

/* 2. Der Lichtstreifen (Identisch zu .row::after) */
.grid-item::after {
    content: '';
    position: absolute;
    top: 0; 
    left: -100%; 
    width: 40%; /* Deine Anpassung */
    height: 100%;
    
    /* Dein angepasster Verlauf */
    background: linear-gradient(
        to right, 
        transparent 0%, 
        rgba(255, 255, 255, 0.18) 50%, 
        transparent 100%
    );
    
    transform: skewX(-25deg);
    pointer-events: none; 
    
    /* Nutzt die gleiche Animation */
    animation: shimmerLoop 30s infinite; 
    z-index: 5;
}
/* === IMMERSIVE GRID (Instagram Style) === */
.grid-item {
    padding: 0 !important; /* Kein Padding, Bild geht bis zum Rand */
    height: 160px;         /* Feste H√∂he f√ºr Einheitlichkeit */
    align-items: stretch !important;
    overflow: hidden !important;
    justify-content: flex-end !important; /* Text nach unten */
    border: 1px solid rgba(255,255,255,0.1) !important;
}

/* Das Bild als Hintergrund der ganzen Karte */
.grid-bg-img {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
    transition: transform 0.5s;
}
.grid-item:hover .grid-bg-img { transform: scale(1.1); }

/* Verlauf unten, damit Text lesbar ist */
.grid-overlay {
    position: absolute; bottom: 0; left: 0; width: 100%; height: 70%;
    background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 100%);
    z-index: 1;
    pointer-events: none;
}

/* Text Container */
.grid-info {
    position: relative; z-index: 2;
    padding: 12px;
    text-align: left;
    display: flex; flex-direction: column;
}

.grid-name {
    font-size: 15px !important; font-weight: 800 !important;
    color: #fff !important; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    margin-bottom: 2px !important;
}

.grid-sub {
    font-size: 11px; color: rgba(255,255,255,0.7); font-weight: 600;
}

/* Badge oben rechts */
.grid-badge-top {
    position: absolute; top: 10px; right: 10px;
    background: var(--accent); color: white;
    font-size: 12px; font-weight: 900;
    padding: 4px 8px; border-radius: 12px;
    z-index: 3;
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
}

/* === GRID STYLES UPDATE (MENU UNTEN RECHTS) === */

/* Der Text-Container */
.grid-info {
    position: relative; z-index: 2;
    padding: 12px;
    /* WICHTIG: Platz rechts lassen f√ºr den Men√º-Button, damit Text nicht √ºberlappt */
    padding-right: 45px !important; 
    text-align: left;
    display: flex; flex-direction: column;
}

/* Der Men√º Button (3 Punkte) */
.grid-menu-btn {
    position: absolute; 
    bottom: 0; 
    right: 0;
    
    width: 45px; height: 45px; /* Gro√üe Klickfl√§che */
    display: flex; align-items: center; justify-content: center;
    
    font-size: 24px; 
    color: rgba(255,255,255,0.9); /* Helles Wei√ü */
    text-shadow: 0 2px 5px rgba(0,0,0,0.8); /* Schatten f√ºr Lesbarkeit */
    
    z-index: 10; /* Ganz oben */
    cursor: pointer;
    transition: transform 0.2s;
}

.grid-menu-btn:active {
    transform: scale(1.2);
    color: var(--accent);
}

/* === RICH LIST STYLE === */

/* Container f√ºr Bild/Icon */
.list-visual {
    width: 54px; 
    height: 54px; 
    flex-shrink: 0;
    margin-right: 15px;
    position: relative;
}

/* Das echte Foto */
.list-thumb-img {
    width: 100%; height: 100%;
    object-fit: cover;
    border-radius: 16px; /* Squircle */
    border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

/* Der Emoji-Placeholder (wenn kein Foto) */
.list-thumb-placeholder {
    width: 100%; height: 100%;
    border-radius: 16px;
    display: flex; align-items: center; justify-content: center;
    font-size: 26px;
    /* Farben werden inline gesetzt, hier nur Fallback */
    background: rgba(255,255,255,0.05);
    box-shadow: inset 0 0 10px rgba(255,255,255,0.05);
}

/* Text Container */
.list-content {
    flex: 1;
    display: flex; flex-direction: column; justify-content: center;
    min-width: 0; /* Wichtig f√ºr Text-Overflow */
}

/* Zeile 1: Name */
.list-top-line {
    display: flex; align-items: center;
    margin-bottom: 3px;
}
.list-name {
    font-size: 16px; 
    font-weight: 800; /* Extra Fett */
    color: var(--text);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.list-fav-star {
    margin-left: 6px; 
    color: #ffb300; 
    font-size: 14px;
    filter: drop-shadow(0 0 5px rgba(255, 179, 0, 0.4));
}

/* Zeile 2: Subtext */
.list-sub-line {
    font-size: 12px; 
    color: var(--sub); 
    font-weight: 500;
    display: flex; align-items: center;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

/* Anpassung der Row-Abst√§nde f√ºr das neue Layout */
.row-main {
    padding: 10px 0 10px 12px !important; /* Etwas Luft lassen */
}
/* === REPARATUR: EIGENE KLASSE F√úR STATS KACHELN === */
.stat-grid-item {
    background: rgba(255, 255, 255, 0.05); /* Leicht heller */
    padding: 15px;
    border-radius: 16px;
    
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* WICHTIG: Linksb√ºndig, nicht zentriert! */
    justify-content: center;
    gap: 4px;
    
    border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    
    /* Reset von m√∂glichen Grid-St√∂rungen */
    height: auto !important; 
    min-height: 0 !important;
}

/* === PAPER MODAL STYLE (Lese-Ansicht) === */
.paper-modal {
    background: #fffbf0 !important; /* Papier-Farbe */
    color: #2c2c2e !important;      /* Dunkle Schrift */
    border-radius: 6px !important;  /* Eckiger */
    box-shadow: 0 10px 40px rgba(0,0,0,0.5) !important;
    max-width: 400px;
    border: none !important;
}

.paper-close {
    background: rgba(0,0,0,0.1) !important;
    color: #333 !important;
}

.paper-header {
    margin-bottom: 20px;
    border-bottom: 2px dashed rgba(0,0,0,0.1);
    padding-bottom: 15px;
    margin-top: 10px;
}

.paper-date {
    font-size: 18px; font-weight: 900; color: #333;
    font-family: 'Fredoka', sans-serif;
}

.paper-loc {
    font-size: 14px; color: #666; margin-top: 4px; font-weight: bold;
}

.paper-text {
    font-family: 'Courier New', Courier, monospace;
    font-size: 16px; line-height: 1.6;
    white-space: pre-wrap; /* Zeilenumbr√ºche behalten */
    font-weight: 600;
}

.paper-footer {
    margin-top: 30px;
    display: flex; justify-content: flex-end;
}

.paper-action-btn {
    background: transparent;
    border: 2px solid #333;
    color: #333;
    border-radius: 30px;
    padding: 8px 16px;
    font-weight: bold;
    font-size: 13px;
    cursor: pointer;
}
.paper-action-btn:active { background: rgba(0,0,0,0.05); transform: scale(0.95); }

/* === MAP BOTTOM SHEET (Option 2: Navigator) === */
.map-sheet {
    position: fixed;
    left: 15px; right: 15px;
    bottom: 95px; /* √úber der Bottom Nav */
    z-index: 8500;

    /* Navigator Look: Dark Glass & Border */
    background: rgba(30, 30, 30, 0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 20px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.6);

    /* Layout */
    display: flex; align-items: center; padding: 15px 20px; gap: 15px;
    
    /* Animation: Startet unsichtbar unten */
    transform: translateY(200%);
    transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
}

.map-sheet.active { 
    transform: translateY(0); 
}

.sheet-info { flex: 1; overflow: hidden; }
.sheet-info h4 { margin: 0; font-size: 16px; font-weight: 800; color: #fff; font-family: 'Fredoka', sans-serif; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.sheet-info p { margin: 2px 0 0 0; font-size: 12px; opacity: 0.7; color: #fff; }

/* === Animierte Pfeile (Das Highlight) === */
.arrow-track {
    display: flex; align-items: center; gap: 2px; margin-right: 5px;
}
.chevron {
    width: 8px; height: 8px;
    border-right: 3px solid #4cd137; border-top: 3px solid #4cd137;
    transform: rotate(45deg); opacity: 0;
    animation: guideArrows 1.5s infinite;
}
.chevron:nth-child(1) { animation-delay: 0s; }
.chevron:nth-child(2) { animation-delay: 0.2s; }
.chevron:nth-child(3) { animation-delay: 0.4s; }

@keyframes guideArrows {
    0% { opacity: 0; transform: translateX(-5px) rotate(45deg); }
    50% { opacity: 1; }
    100% { opacity: 0; transform: translateX(5px) rotate(45deg); }
}

/* === Der Gr√ºne Action Button === */
.v2-btn {
    width: 44px; height: 44px; border-radius: 50%;
    background: #4cd137; color: #000; border: none;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; font-weight: bold; cursor: pointer;
    box-shadow: 0 0 15px rgba(76, 209, 55, 0.5);
    transition: transform 0.2s;
    flex-shrink: 0;
}
.v2-btn:active { transform: scale(0.9); }

/* === CSS REPARATUR: MAP SHEET === */
.map-sheet {
    /* ... deine alten Werte lassen (position, bottom etc.) ... */
    
    /* √ÑNDERUNG: Von 150% auf 200% erh√∂hen, damit es sicher weg ist */
    transform: translateY(200%); 
    
    /* Optional: Opacity hinzuf√ºgen, damit es beim Start unsichtbar ist */
    opacity: 0;
    pointer-events: none; /* Klicks gehen durch wenn versteckt */
    
    transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.3s;
}

.map-sheet.active { 
    transform: translateY(0); 
    opacity: 1;
    pointer-events: all;
}


/* === MEMORY DECK (SWIPE STACK) === */
.deck-section {
    position: relative;
    width: 100%;
    height: 380px; /* Platz f√ºr den Stapel */
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    margin-bottom: 30px;
    perspective: 1000px;
    overflow: hidden; /* Damit wegfliegende Karten nicht scrollen */
}

.deck-container {
    position: relative;
    width: 280px; height: 340px;
}

.deck-card {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    border-radius: 20px;
    background: var(--card-solid);
    border: 1px solid var(--btn);
    box-shadow: 0 15px 35px rgba(0,0,0,0.15);
    display: flex; flex-direction: column;
    overflow: hidden;
    cursor: grab;
    transform-origin: 50% 120%; /* Drehpunkt unten f√ºr besseres Feeling */
    user-select: none;
    transition: transform 0.1s linear, opacity 0.3s;
}
/* Im Darkmode etwas mehr Glow */
body.dark .deck-card { box-shadow: 0 15px 40px rgba(0,0,0,0.4); border-color: rgba(255,255,255,0.1); }

.deck-card:active { cursor: grabbing; }

/* Bild-Bereich */
.dc-img-area {
    height: 60%; width: 100%; position: relative; background: var(--btn);
}
.dc-img {
    width: 100%; height: 100%; object-fit: cover; pointer-events: none;
}
.dc-overlay {
    position: absolute; bottom: 0; left: 0; width: 100%; height: 50%;
    background: linear-gradient(to top, var(--card-solid), transparent);
}

/* Text-Bereich */
.dc-body {
    flex: 1; padding: 15px; position: relative;
    display: flex; flex-direction: column;
}

.dc-badge {
    position: absolute; top: 5px; right: 15px;
    background: var(--card-solid); 
    padding: 5px 12px; border-radius: 20px;
    font-size: 11px; font-weight: bold; text-transform: uppercase;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    border: 1px solid var(--btn);
    color: var(--sub);
}

.dc-title {
    font-family: 'Fredoka', sans-serif; font-size: 22px; margin: 0 0 5px 0;
    color: var(--text);
}

/* Die Handschrift-Notiz */
.dc-note {
    font-family: 'Caveat', cursive; 
    font-size: 22px; line-height: 1.2;
    color: var(--text); opacity: 0.8;
    transform: rotate(-1deg);
    margin-bottom: auto; /* Schiebt Datum nach unten */
}

/* Neuer Profi-Look f√ºr Datum & Uhrzeit */
.dc-date {
    font-family: ui-monospace, 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace; /* Tech Font */
    font-size: 12px; 
    font-weight: 700;
    color: var(--accent); /* Deine Akzentfarbe */
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px dashed rgba(128, 128, 128, 0.3); /* Feine Trennlinie */
    display: flex; 
    justify-content: space-between; /* Datum links, Zeit rechts */
}

/* Animation beim Wegwerfen */
.is-flying { transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important; opacity: 0 !important; }

/* Empty State */
.deck-empty {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    text-align: center; opacity: 0.6; pointer-events: none;
}
</style>

</head>
<body>

<!-- Global Toast & Undo -->
<div id="errorToast" class="error-toast"></div>
<div id="undoToast" class="undo-toast">
    <span id="undoText">Gez√§hlt: L√∂we (+1)</span>
    <button class="undo-btn" onclick="safeRun(performUndo)">R√ºckg√§ngig</button>
</div>

<!-- HEADER CONTROLS (Ersetzen) -->
<div class="header-controls">
  <button class="icon-btn-header" onclick="safeRun(openSettings)" title="Einstellungen">‚öôÔ∏è</button>
  <!-- WICHTIG: Hier openInfoModal statt toggleInfo -->
  <button class="icon-btn-header info" onclick="safeRun(openInfoModal)" title="Hilfe anzeigen">‚ÑπÔ∏è</button>
</div>

<!-- HEADER LOGO FINAL -->
<h1 class="app-brand">
    <span class="brand-tier">
        Tier
        <!-- WICHTIG: Die Tatzen liegen HIER DRIN -->
        <span class="paw paw-br">üêæ</span>
        <span class="paw paw-tl">üêæ</span>
    </span>
    <span class="brand-ticker">Ticker</span>
    <span class="brand-icon-pop">+1</span>
</h1>

<!-- INFO BOX (Anleitung f√ºr Endanwender) -->
<div id="infoBox" class="glass-panel" style="display:none; padding:20px; margin-bottom:20px; border-radius:20px;">
<h3>üìñ Anleitung</h3>
<p>Willkommen! So benutzt du die App:</p>
<ul style="line-height:1.6; padding-left:20px;">
<li><strong>üî¢ Z√§hlen:</strong> Tippe auf das (+), um ein Tier zu z√§hlen.</li>
<li><strong>üîç Details & Historie:</strong> Tippe auf den Namen oder das Bild eines Tiers, um alle Sichtungen zu sehen. <em>(Schlie√üen nur √ºber das X oben rechts m√∂glich)</em>.</li>
<li><strong>üìù Notizen:</strong> Klicke auf das üìù Symbol, um eine Notiz oder eine genaue Uhrzeit einzutragen.</li>
<li><strong>‚≠ê Favoriten:</strong> Markiere deine Lieblingstiere mit dem Stern, damit sie oben stehen.</li>
<li><strong>‚öôÔ∏è Verwalten:</strong> Unten auf "Admin" kannst du neue Tiere anlegen oder Backups machen.</li>
</ul>
</div>
<div id="scrollTopBtn" onclick="window.scrollTo({top:0, behavior:'smooth'})">‚¨ÜÔ∏è</div>


<!-- === VIEW: LIST (Startseite) === -->
<div id="view-list" class="view-section active">
<div class="list-header">
      <!-- Suchleiste -->
      <input id="listSearch" class="search-bar" placeholder="üîç Tier suchen..." oninput="safeRun(debouncedRender)">
      
      <!-- Neuer gro√üer Button -->
      <button class="btn-sighting-large" onclick="safeRun(openQuickSighting)">
          <span style="font-size:18px; font-weight:900;">+</span> Sichtung
      </button>
  </div>


  <!-- Tag Filter bleibt hier -->
  <div id="tagFilterContainer" class="tag-scroll">...</div>


<!-- NEU: Container f√ºr Sortieren/Ansicht -->
  <div id="floatingControls" class="list-controls-floating">
      <button class="float-btn" onclick="safeRun(toggleViewMode)" id="viewToggleBtn" title="Ansicht wechseln">üìú</button>
      <button class="float-btn" onclick="safeRun(cycleSort)" id="sortBtn" title="Sortieren">‚≠ê</button>
  </div>

  <!-- 1. HIER ERSCHEINT DER EINKLAPPEN BUTTON (Dynamisch per JS) -->
  <div id="listToggleContainer" style="margin-bottom: 10px; min-height: 5px;"></div>

  <!-- 2. Die Liste (Sneak Peek Wrapper) -->
  <div id="sneakPeekContainer" class="sneak-peek-wrapper collapsed">
      <!-- Overlay zum Ausklappen -->
      <div class="sneak-peek-overlay" onclick="safeRun(expandList)"></div>
      <div id="list" style="padding-bottom: 20px;"></div>
  </div>
  
  <!-- Hinweis Text (nur sichtbar wenn zugeklappt) -->
  <div id="sneakHint" class="sneak-peek-hint">‚ñº Tippe auf die Liste zum Ausklappen ‚ñº</div>

  <!-- 3. Favoriten Container (Extra Bereich DARUNTER) -->
  <div id="favContainer" style="margin-top: 20px;"></div>

   <!-- === ENDE √ÑNDERUNG === -->
 <div id="emptyState" style="text-align:center; padding:60px 20px; color:var(--sub); display:none;">
      <div style="font-size:60px; margin-bottom:15px; opacity:0.5">üêæ</div>
      <h3>Keine Tiere gefunden</h3>
      <p>Gehe auf "Admin" um neue Tiere anzulegen.</p>
  </div>
</div>


<!-- === VIEW: ADMIN (Verwalten) === -->
 <!-- === VIEW: ADMIN (Verwalten) === -->
<div id="view-admin" class="view-section">
  
  <!-- BUBBLE 1: NEUES TIER (Kein Akkordeon, bleibt statisch offen) -->
  <div class="card-section">
    <h3>üêæ Neues Tier anlegen</h3>
    <div class="edit-tools" style="margin-bottom:0">
      <label class="file-label">
          <span style="font-size:24px">üñºÔ∏è</span> Galerie
          <input type="file" id="fileUpload" hidden accept="image/*" onchange="safeRun(handleImageUpload, this)">
      </label>
      <label class="file-label">
          <span style="font-size:24px">üì∑</span> Kamera
          <input type="file" id="cameraUpload" hidden accept="image/*" capture="environment" onchange="safeRun(handleImageUpload, this)">
      </label>
    </div>
    
    <div style="display:flex; gap:10px; margin:15px 0;">
        <input id="emojiInput" placeholder="ü¶Å" size="3" style="width:60px; text-align:center; font-size:24px">
        <input id="nameInput" placeholder="Name des Tiers (z.B. Rotfuchs)" style="flex:1">
    </div>
    
    <div style="margin-bottom:15px">
        <input id="tagInput" placeholder="Kategorie (z.B. Katze, V√∂gel)..." list="tagSuggestions">
        <datalist id="tagSuggestions">
            <option value="Katze"><option value="Hund"><option value="Fuchs">
            <option value="Hase"><option value="Igel"><option value="Marder">
            <option value="V√∂gel"><option value="Insekten">
        </datalist>
    </div>
    
    <div id="imgPreview" style="display:none; margin-bottom:15px; position:relative; width:fit-content; margin: 0 auto 15px auto;">
        <img id="previewEl" src="" style="width:80px; height:80px; border-radius:20px; object-fit:cover; border:2px solid var(--accent)">
        <div onclick="safeRun(clearImage)" style="position:absolute; top:-5px; right:-5px; background:red; color:white; border-radius:50%; width:24px; height:24px; display:flex; align-items:center; justify-content:center; cursor:pointer">‚úñ</div>
    </div>

    <button onclick="safeRun(addAnimal)" style="width:100%; background:var(--accent); color:#fff; padding:14px;">Tier Speichern ‚ú®</button>
  </div>

  <!-- BUBBLE 2: ORTE (Akkordeon) -->
  <div class="card-section">
    <!-- ONCLICK JETZT NUR HIER IM HEADER -->
    <div class="accordion-header" onclick="toggleAccordion(this)">
        <h3>üìç Orte & Suche</h3>
        <span class="acc-chevron">‚ñº</span>
    </div>
    <div class="accordion-content">
        <div class="accordion-inner">
            <p style="font-size:12px; opacity:0.7; margin-bottom:10px">Suche Orte oder nutze GPS, um die Adresse automatisch zu finden.</p>
            <div style="display:flex; gap:8px; align-items:flex-start;">
                <div class="autocomplete-container" style="flex:1">
                  <input id="osmInput" placeholder="Ort suchen (Enter)...">
                  <div id="osmResults" class="autocomplete-results"></div>
                </div>
                <button onclick="safeRun(locateMe)" title="Mein Standort" style="background:var(--card-solid); border:1px solid var(--btn); min-width:44px">üìç</button>
                <button onclick="safeRun(addManualLocation)" style="min-width:44px;">üíæ</button>
            </div>
            <div style="margin-top:15px; border-top:1px solid var(--btn); padding-top:10px;">
                <span style="font-size:12px; opacity:0.7">Gespeicherte Orte (zum L√∂schen antippen):</span>
                <div id="locationListDisplay" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; max-height:120px; overflow-y:auto;"></div>
            </div>
        </div>
    </div>
  </div>

  <!-- BUBBLE 3: DATEN (Akkordeon) -->
  <div class="card-section">
    <!-- ONCLICK JETZT NUR HIER IM HEADER -->
    <div class="accordion-header" onclick="toggleAccordion(this)">
        <h3>üíæ Daten & Sicherung</h3>
        <div id="backupHeaderBadge" class="header-warning-badge">‚ö†Ô∏è Backup f√§llig!</div>
        <span class="acc-chevron">‚ñº</span>
    </div>
    <div class="accordion-content">
        <div class="accordion-inner">
            <!-- Warnbox -->
            <div id="backupWarningBox" class="backup-alert" style="display:none;">
                <div>
                    ‚ö†Ô∏è Dein letztes Backup ist <strong id="backupDaysCount">lange</strong> her.<br>
                    <span style="opacity:0.8; font-size:11px;">Sichere deine Sammlung lieber mal!</span>
                </div>
                <button onclick="document.getElementById('backupWarningBox').style.display='none'" title="Ausblenden">‚úï</button>
            </div>

            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px;">
                <button onclick="safeRun(downloadBackup)">üì¶ Backup</button>
                <button onclick="safeRun(exportCSV)">üìÑ CSV Export</button>
                <button onclick="document.getElementById('importFile').click()">üì• Import</button>
                <input type="file" id="importFile" accept="application/json" hidden onchange="safeRun(importBackup, event)">
            </div>

            <div style="margin-top:20px; font-size:12px; opacity:0.8;">
                <div style="display:flex; justify-content:space-between"><span>Bild-Datenbank (IndexedDB):</span><span id="storageText">Lade...</span></div>
                <div class="xp-bar-bg" style="height:6px; margin-top:5px; background:var(--btn)"><div id="storageBar" class="xp-bar-fill" style="width:0%; background:var(--accent)"></div></div>
            </div>
        </div>
    </div>
  </div>

  <!-- BUBBLE 4: PAPIERKORB (Akkordeon) -->
  <div id="trashSection" class="card-section" style="border-color:var(--err-bg);">
      <!-- ONCLICK JETZT NUR HIER IM HEADER -->
      <div class="accordion-header" onclick="toggleAccordion(this)">
        <h3 style="color:var(--err-text)">üóëÔ∏è Papierkorb</h3>
        <span class="acc-chevron">‚ñº</span>
      </div>
      <div class="accordion-content">
        <div class="accordion-inner">
          <p style="font-size:12px; opacity:0.7; margin-bottom:10px">Gel√∂schte Elemente werden nach 30 Tagen automatisch entfernt.</p>
          <div id="trashList" style="max-height:200px; overflow-y:auto; margin-bottom:15px; background:var(--bg); border-radius:12px;"></div>
          <button onclick="safeRun(emptyTrash)" style="width:100%; background:var(--err-bg); color:var(--err-text); border:1px solid var(--err-text)">
              Papierkorb jetzt leeren
          </button>
        </div>
      </div>
  </div>    

  <div style="text-align:center; margin-top:40px; padding-top:20px; border-top:1px dashed var(--btn);">
      <p style="color:var(--err-text); font-weight:bold; font-size:12px; margin-bottom:10px">‚ö†Ô∏è GEFAHRENZONE</p>
      <button onclick="safeRun(hardReset)" style="background:transparent; color:var(--err-text); border:1px solid var(--err-text); font-size:12px">‚ö†Ô∏è App vollst√§ndig zur√ºcksetzen</button>
  </div>
</div>

<!-- === VIEW: MAP (Karte) === -->
<div id="view-map" class="view-section">
    <div id="map"></div>
    <div style="text-align:center; opacity:0.7; font-size:13px">Zeigt Orte deiner Sichtungen aller Jahre.</div>
</div>

<!-- === VIEW: STATS (Statistik) === -->
<div id="view-stats" class="view-section">
  
  <!-- Header: Nur der Button (Rechtsb√ºndig) -->
  <div style="display:flex; justify-content:flex-end; margin-bottom:20px; padding-top:5px;">
      <select id="statsYearSelect" onchange="safeRun(renderStats)" title="Zeitraum w√§hlen"></select>
  </div>

  <!-- Inhalt Container -->
  <div id="statsContainer">
    <div id="statsContent"></div>
  </div>
  
  <!-- Share Button -->
  <button onclick="safeRun(generateShareCard)" style="width:100%; margin-top:30px; background:var(--text); color:var(--bg); border-radius:20px; padding:15px; font-weight:bold; box-shadow: var(--shadow); display:flex; align-items:center; justify-content:center; gap:8px; transition:transform 0.2s;">
      <span style="font-size:18px;">üé®</span> Share Card erstellen
  </button>
  
  <div style="height:20px;"></div>
</div>

<!-- MAP BOTTOM SHEET (Navigator Style) -->
<div id="mapSheet" class="map-sheet">
    <!-- Icon links -->
    <div style="font-size:30px">üìç</div>
    
    <!-- Text Info -->
    <div class="sheet-info">
        <h4 id="sheetTitle">Ort Name</h4>
        <p id="sheetSub">Lade Infos...</p>
    </div>
    
    <!-- Die animierten Pfeile -->
    <div class="arrow-track">
        <div class="chevron"></div>
        <div class="chevron"></div>
        <div class="chevron"></div>
    </div>

    <!-- Der Action Button (mit alter ID f√ºr JS-Kompatibilit√§t) -->
    <button id="sheetJumpBtn" class="v2-btn">‚ûî</button>
</div>


<!-- === BOTTOM NAV === -->
<div class="bottom-nav">
    <button class="nav-item active" onclick="safeRun(switchView, 'view-list', this)">
        <span class="nav-icon">üìã</span>
        <span>Liste</span>
    </button>
    
    <!-- HIER GE√ÑNDERT: Von "Admin/Zahnrad" zu "Verwaltung/Werkzeug" -->
    <button class="nav-item" onclick="safeRun(switchView, 'view-admin', this)">
        <span class="nav-icon">üõ†Ô∏è</span>
        <span>Verwaltung</span>
    </button>
    
    <button class="nav-item" onclick="safeRun(switchView, 'view-map', this)">
        <span class="nav-icon">üåç</span>
        <span>Karte</span>
    </button>
    <button class="nav-item" onclick="safeRun(switchView, 'view-stats', this)">
        <span class="nav-icon">üìä</span>
        <span>Stats</span>
    </button>
</div>

<!-- MODALS WITH SWIPE HANDLE -->
<div id="detailModal" class="modal">
    <div class="modal-content">
        <!-- SHEET HANDLE ENTFERNT, damit man nicht denkt, man kann swipen -->
        <div class="close-btn" onclick="closeModal('detailModal')">‚úï</div>
        <div style="display:flex; align-items:center; gap:10px; margin-bottom:20px; padding-bottom:10px; border-bottom:1px solid var(--btn)">
             <div class="modal-icon" id="detailIcon" style="font-size:50px; line-height:1"></div>
             <div>
                 <h2 id="detailTitle" style="margin:0">Tier</h2>
                 <select id="detailYearSelect" onchange="safeRun(updateDetailChart)" style="padding:4px; font-size:13px; margin-top:4px"></select>
             </div>
        </div>
        <div id="modalBody"></div>
    </div>
</div>


<!-- VIEW NOTE MODAL (Lese-Ansicht) -->
<div id="noteViewModal" class="modal">
  <div class="modal-content paper-modal">
    <div class="close-btn paper-close" onclick="closeModal('noteViewModal')">‚úï</div>
    
    <!-- Header: Datum & Ort -->
    <div class="paper-header">
        <div id="nvDate" class="paper-date">12.10.2024</div>
        <div id="nvLoc" class="paper-loc">üìç Garten</div>
    </div>

    <!-- Der Inhalt -->
    <div class="paper-body">
        <div id="nvText" class="paper-text">Lade Notiz...</div>
    </div>

    <!-- Footer: Aktionen -->
    <div class="paper-footer">
        <button id="nvEditBtn" class="paper-action-btn">‚úèÔ∏è Bearbeiten</button>
    </div>
  </div>
</div>


<div id="noteModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('noteModal')">‚úï</div>
    
    <h3 id="noteModalTitle">‚ûï Sichtung</h3>

    <!-- NEU: Tier-Auswahl (Nur sichtbar bei "Schnell-Sichtung") -->
    <div id="noteAnimalWrapper" style="display:none; margin-bottom:15px; position:relative;">
        <label style="font-size:12px; font-weight:bold; opacity:0.7; margin-bottom:4px; display:block;">Welches Tier?</label>
        <input id="noteAnimalInput" placeholder="üîç Tiername tippen (z.B. Wolf)..." style="font-weight:bold; border:2px solid var(--accent);">
        <!-- Autocomplete Liste -->
        <div id="noteAnimalResults" class="autocomplete-results"></div>
    </div>

    <!-- Bestehende Inputs -->
    <input type="date" id="noteDate" style="margin-bottom:10px">
    
<!-- ZEIT & ORT (Nebeneinander) -->
    <div style="display:flex; gap:10px; margin-bottom:10px; align-items:flex-start;">
        <!-- Zeit -->
        <input type="time" id="noteTime" style="width:110px; flex-shrink:0;">
        
        <!-- Ort (Jetzt als Smart Input) -->
        <div style="position:relative; flex:1;">
            <input id="noteLoc" placeholder="üìç Ort (tippen/w√§hlen)..." autocomplete="off">
            <!-- Container f√ºr Vorschl√§ge -->
            <div id="noteLocResults" class="autocomplete-results"></div>
        </div>
    </div>

    <textarea id="noteText" placeholder="Was hast du beobachtet?" rows="4" style="margin-bottom:15px"></textarea>
    <button id="noteSaveBtn" style="width:100%; background:var(--accent); color:#fff; padding:15px">Speichern</button>
  </div>
</div>

<div id="importModal" class="modal">
  <div class="modal-content" style="text-align:center">
    <div class="sheet-handle"></div>
    <h3>Backup Importieren</h3>
    <p style="opacity:0.7">Wie m√∂chtest du die Daten importieren?</p>
    <div class="import-actions">
        <button class="btn-merge" onclick="safeRun(confirmImport, 'merge')">‚ú® Zusammenf√ºgen (Smart Merge)<br><small>F√ºgt neue Daten hinzu, beh√§lt alte</small></button>
        <button class="btn-overwrite" onclick="safeRun(confirmImport, 'overwrite')" style="background:var(--err-bg); color:var(--err-text); border:1px solid var(--err-text)">‚ö†Ô∏è Alles √úberschreiben<br><small>L√∂scht ALLE aktuellen Daten</small></button>
        <button onclick="safeRun(confirmImport, 'cancel')">Abbrechen</button>
    </div>
  </div>
</div>

<div id="iconModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('iconModal')">‚úï</div>
    
    <h3>‚úèÔ∏è Tier bearbeiten</h3>
    
    <!-- Bilder Upload -->
    <div class="edit-tools">
       <label class="file-label">üñºÔ∏è Galerie<input type="file" id="editFileInput" hidden accept="image/*" onchange="safeRun(handleEditFile, this)"></label>
       <label class="file-label">üì∑ Foto<input type="file" id="editCameraInput" hidden accept="image/*" capture="environment" onchange="safeRun(handleEditFile, this)"></label>
    </div>

    <!-- Bild Vorschau -->
    <div id="editPreviewContainer" style="text-align:center; display:none; margin-bottom:15px">
        <img id="editPreviewImg" src="" style="width:100px; height:100px; border-radius:20px; object-fit:cover; border:3px solid var(--accent); box-shadow:0 5px 15px rgba(0,0,0,0.2);">
        <br><button onclick="safeRun(removeEditImage)" style="margin-top:8px; font-size:12px; padding:6px 12px; background:var(--err-bg); color:var(--err-text); border:none; border-radius:15px; font-weight:bold;">üóëÔ∏è Bild entfernen</button>
    </div>

    <!-- NEU: Name √§ndern -->
    <label style="font-size:12px; font-weight:bold; opacity:0.7; margin-bottom:4px; display:block;">Name:</label>
    <div style="display:flex; gap:10px; margin-bottom:15px">
       <input id="editEmoji" style="width:60px; font-size:24px; text-align:center" placeholder="Icon">
       <input id="editName" placeholder="Tiername (z.B. Wolf)" style="font-weight:bold;">
    </div>

    <!-- Kategorien -->
    <label style="font-size:12px; font-weight:bold; opacity:0.7; margin-bottom:4px; display:block;">Kategorie / Tags:</label>
    <input id="editTag" placeholder="z.B. S√§ugetiere, Wald (Komma getrennt)" style="margin-bottom:20px;">

    <button onclick="safeRun(saveIconEdit)" style="width:100%; background:var(--accent); color:#fff; padding:15px; font-size:16px;">üíæ √Ñnderungen speichern</button>
  </div>
</div>

<div id="notifyModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('notifyModal')">‚úï</div>
    
    <h3>‚öôÔ∏è Einstellungen</h3>

    <!-- GRUPPE 1: ERSCHEINUNGSBILD -->
    <h4 style="margin-top:20px; margin-bottom:10px; opacity:0.7; font-size:12px; text-transform:uppercase;">Design & Ansicht</h4>
    
    <!-- Dark Mode (Verschoben aus Admin) -->
    <div style="background:var(--bg); padding:15px; border-radius:12px; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px">
        <span>üåô Dark Mode</span>
        <label class="switch">
            <input type="checkbox" id="settingDarkToggle" onchange="safeRun(toggleDarkMode)">
            <span class="slider"></span>
        </label>
    </div>

    <!-- Kompakt Modus -->
    <div style="background:var(--bg); padding:15px; border-radius:12px; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px">
        <span>üì± Kompakt-Ansicht (klein)</span>
        <label class="switch">
            <input type="checkbox" id="compactToggle" onchange="safeRun(toggleCompactMode)">
            <span class="slider"></span>
        </label>
    </div>

    <!-- GRUPPE 2: TON & BENACHRICHTIGUNG -->
    <h4 style="margin-top:20px; margin-bottom:10px; opacity:0.7; font-size:12px; text-transform:uppercase;">Ton & Alarm</h4>

    <!-- Stummschalten (Verschoben aus Header) -->
    <div style="background:var(--bg); padding:15px; border-radius:12px; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px">
        <span>üîá Stummschalten</span>
        <label class="switch">
            <input type="checkbox" id="settingMuteToggle" onchange="safeRun(toggleMuteState)">
            <span class="slider"></span>
        </label>
    </div>

    <!-- Inaktivit√§ts-Alarm -->
    <div style="background:var(--bg); padding:15px; border-radius:12px; display:flex; justify-content:space-between; align-items:center; margin-bottom:15px">
        <span>‚è∞ Inaktivit√§ts-Alarm</span>
        <label class="switch"><input type="checkbox" id="notifyToggle"><span class="slider"></span></label>
    </div>
    
    <!-- Alarm Details -->
    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px; padding:0 10px;">
        <span>Erinnern nach Tagen:</span> <input type="number" id="notifyDays" value="7" style="width:80px; padding:8px;">
    </div>
    <div style="display:flex; gap:10px; margin-bottom:20px">
        <button onclick="safeRun(saveNotifySettings)" style="flex:1; background:var(--accent); color:#fff">Speichern</button>
        <button onclick="safeRun(testNotification)" style="flex:1;">Testen</button>
    </div>

    <hr style="opacity:0.2; margin: 20px 0;">
    
    <!-- KALENDER -->
    <h4 style="margin-bottom:10px; opacity:0.7; font-size:12px; text-transform:uppercase;">üìÖ Kalender-Export</h4>
    <div style="display:flex; gap:5px; margin-bottom:10px">
        <select id="icsFreq"><option value="WEEKLY">W√∂chentlich</option><option value="DAILY">T√§glich</option></select>
        <input type="time" id="icsTime" value="19:00">
    </div>
    <select id="icsDay" style="margin-bottom:10px"><option value="SA">Samstag</option><option value="SU">Sonntag</option></select>
    <button onclick="safeRun(downloadICS)" style="width:100%">üìÖ ICS Datei laden</button>
  </div>
</div>

<!-- PAPIERKORB DETAILS MODAL -->
<div id="trashDetailModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('trashDetailModal')">‚úï</div>
    <h3>üóëÔ∏è Gel√∂schtes Element</h3>
    
    <div style="background:var(--bg); padding:15px; border-radius:12px; margin-bottom:15px; font-size:14px; line-height:1.6">
        <div style="margin-bottom:8px"><strong>Art:</strong> <span id="tdType">...</span></div>
        <div style="margin-bottom:8px"><strong>Name:</strong> <span id="tdName" style="color:var(--accent); font-weight:bold">...</span></div>
        <div style="margin-bottom:8px"><strong>Datum:</strong> <span id="tdDate">...</span></div>
        <div style="margin-bottom:8px"><strong>Zeit:</strong> <span id="tdTime">...</span></div>
        <div style="margin-bottom:8px"><strong>Ort:</strong> <span id="tdLoc">...</span></div>
        <div><strong>Notiz:</strong> <div id="tdNote" style="background:var(--card); padding:8px; border-radius:8px; margin-top:4px; font-style:italic; opacity:0.8">...</div></div>
    </div>

    <button id="tdRestoreBtn" style="width:100%; background:var(--accent); color:#fff; padding:15px">‚ôªÔ∏è Wiederherstellen</button>
  </div>
</div>

<!-- HEUTE DETAILS MODAL -->
<div id="todayModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('todayModal')">‚úï</div>
    <h3>üìÖ Heute entdeckt</h3>
    <p style="font-size:13px; opacity:0.6; margin-top:-10px; margin-bottom:20px">Chronologische Liste deiner heutigen Sichtungen.</p>
    
    <div id="todayListContainer" class="today-list-container">
        <!-- Hier wird die Liste reingeladen -->
    </div>
  </div>
</div>

<!-- MEMORY DECK SECTION -->
  <div id="memoryDeckWrapper" style="display:none; animation:fadeIn 0.5s;">
      <div style="text-align:center; margin-bottom:5px; margin-top:10px;">
          <h3 style="font-size:14px; text-transform:uppercase; letter-spacing:2px; opacity:0.6; margin:0;">Daily Memories</h3>
          <div style="font-size:11px; opacity:0.4;">Deine Zufalls-Fundst√ºcke</div>
      </div>
      
      <div class="deck-section">
          <div class="deck-container" id="cardDeck">
               <div class="deck-empty">
                   <div style="font-size:40px; margin-bottom:10px;">‚ú®</div>
                   <div>Alle Erinnerungen gesehen!</div>
               </div>
               <!-- Karten werden hier generiert -->
          </div>
      </div>
  </div>

<!-- LIGHTBOX F√úR BILDER -->
<div id="lightboxModal" onclick="closeImageLightbox()">
    <img id="lightboxImg" src="" alt="Gro√üansicht">
</div>

<!-- LEAFLET JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<!-- === NEU: INFO MODAL (Mit Wiederholen-Button) === -->
<!-- === NEU: INFO MODAL (Mit Anleitung & Wiederholen-Button) === -->
<div id="infoModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('infoModal')">‚úï</div>
    
    <div style="text-align:center; margin-bottom:20px;">
        <div style="font-size:40px; margin-bottom:10px;">üìñ</div>
        <h2 style="margin:0;">Anleitung & Hilfe</h2>
    </div>

    <div style="background:var(--bg); padding:20px; border-radius:16px; font-size:14px; line-height:1.6; margin-bottom:20px; color:var(--text); text-align:left;">
        <p style="margin-top:0;"><strong>Willkommen beim Tier Ticker!</strong> üêæ<br>Deine App, um Beobachtungen in der Natur einfach festzuhalten.</p>
        
        <h4 style="margin:15px 0 5px 0; color:var(--accent)">1. Z√§hlen & Erfassen</h4>
        <p style="margin:0; opacity:0.85;">
            Dr√ºcke oben auf den gro√üen <b style="color:var(--accent)">+ Sichtung</b> Button, um schnell ein Tier zu notieren. Zeit & Ort werden automatisch gespeichert.<br>
            Alternativ: Tippe auf das kleine <b>+</b> in der Liste, um den Z√§hler hochzusetzen.
        </p>
        
        <h4 style="margin:15px 0 5px 0; color:var(--accent)">2. Details & Verlauf</h4>
        <p style="margin:0; opacity:0.85;">
            Tippe auf den <b>Namen oder das Bild</b> eines Tiers, um alle Sichtungen, Statistiken und Fotos zu sehen. Dort kannst du Eintr√§ge auch bearbeiten oder l√∂schen.
        </p>
        
        <h4 style="margin:15px 0 5px 0; color:var(--accent)">3. Verwalten & Backup</h4>
        <p style="margin:0; opacity:0.85;">
            Unten unter <b>"Verwaltung"</b> (Werkzeug-Symbol) kannst du manuell neue Arten anlegen, Orte verwalten und Backups erstellen.
        </p>
        
        <div style="margin-top:15px; padding-top:10px; border-top:1px solid var(--btn); font-size:14px; font-style:italic; opacity:0.7;">
            üîí Deine Daten bleiben zu 100% offline auf diesem Ger√§t. Bitte regelm√§√üig Backupdatei erstellen und herunterladen (im Verwaltungsbereich), sonst sind deine Daten verloren bei Browserdatenl√∂schung!
        </div>
    </div>

    <!-- DER KNOPF ZUM WIEDERHOLEN -->
    <button onclick="startTutorial(true)" style="width:100%; background:var(--card); border:2px solid var(--accent); color:var(--accent); font-weight:bold; padding:15px; border-radius:16px; font-size:15px;">
        üéì Tutorial / F√ºhrung wiederholen
    </button>
    
    <p style="text-align:center; font-size:11px; opacity:0.4; margin-top:15px;">Tier Ticker</p>
  </div>
</div>

<!-- === NEU: ONBOARDING CONTAINER === -->
<!-- 1. Der dunkle Hintergrund (Klicksperre) -->
<div id="onboardingOverlay"></div>

<!-- 2. Die Sprechblase (Separat, damit sie immer oben ist) -->
<div id="onboardingBubble" class="onboarding-box" style="display:none;">
    <h3 id="tourTitle">Willkommen!</h3>
    <p id="tourText">Text hier...</p>
    <div class="onboarding-btn-row">
        <button onclick="endTutorial()" style="background:transparent; border:1px solid var(--sub); font-size:12px; padding:8px;">Beenden</button>
        <button id="tourNextBtn" onclick="nextStep()" style="background:var(--accent); color:#fff; flex:1">Weiter ‚ûî</button>
    </div>
</div>

<script>
/** 
 * === TIER TICKER CORE ===
 * Fixes: Disabled Swipe for Details View
 */

// === 1. SWIPE GESTURE HANDLER ===
function initSwipeGestures() {
    let startY = 0;
    let currentModalContent = null;

    document.addEventListener('touchstart', (e) => {
        const handle = e.target.closest('.sheet-handle');
        const content = e.target.closest('.modal-content');
        
        // HIER WIRD DIE √ÑNDERUNG GEMACHT:
        // Wenn das Modal die ID 'detailModal' hat, brechen wir ab (kein Swipe)
        if (content && content.parentElement.id === 'detailModal') return;

        // Only allow swipe if touching handle OR touching content at the very top (scrolled up)
        if (content && (handle || content.scrollTop === 0)) {
            currentModalContent = content;
            startY = e.touches[0].clientY;
            // Remove transition for instant drag response
            currentModalContent.style.transition = 'none';
        }
    }, {passive: true});

    document.addEventListener('touchmove', (e) => {
        if (!currentModalContent) return;
        const currentY = e.touches[0].clientY;
        const delta = currentY - startY;

        // Only move if dragging DOWN
        if (delta > 0) {
            e.preventDefault(); // Prevent scrolling body
            currentModalContent.style.transform = `translateY(${delta}px)`;
        }
    }, {passive: false});

    document.addEventListener('touchend', (e) => {
        if (!currentModalContent) return;
        const delta = e.changedTouches[0].clientY - startY;

        // Restore transition for smooth bounce back or exit
        currentModalContent.style.transition = 'transform 0.3s ease-out';

        if (delta > 120) { // Threshold to close
            const modalId = currentModalContent.parentElement.id;
            closeModal(modalId);
            // Reset transform AFTER animation closes it (timeout matches css transition)
            setTimeout(() => { 
                currentModalContent.style.transform = ''; 
                currentModalContent.style.transition = '';
            }, 300);
        } else {
            // Bounce back
            currentModalContent.style.transform = '';
        }
        currentModalContent = null;
    });
}

// === 2. INDEXED DB WRAPPER (Async Image Storage) ===
const DB_NAME = 'TierAppDB';
const STORE_IMGS = 'images';
const dbPromise = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => { e.target.result.createObjectStore(STORE_IMGS); };
    req.onsuccess = e => resolve(e.target.result);
    req.onerror = e => reject(e);
});

async function dbSaveImg(id, dataUrl) {
    const db = await dbPromise;
    return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_IMGS, 'readwrite');
        tx.objectStore(STORE_IMGS).put(dataUrl, id);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject();
    });
}
async function dbGetImg(id) {
    const db = await dbPromise;
    return new Promise(resolve => {
        const tx = db.transaction(STORE_IMGS, 'readonly');
        const req = tx.objectStore(STORE_IMGS).get(id);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => resolve(null);
    });
}
async function dbDelImg(id) {
    const db = await dbPromise;
    const tx = db.transaction(STORE_IMGS, 'readwrite');
    tx.objectStore(STORE_IMGS).delete(id);
}
async function dbCount() {
    const db = await dbPromise;
    return new Promise(resolve => {
        const req = db.transaction(STORE_IMGS, 'readonly').objectStore(STORE_IMGS).count();
        req.onsuccess = () => resolve(req.result);
    });
}

// === 3. GLOBALS & CONFIG ===
const currentSystemYear = new Date().getFullYear();
let animals = []; 
let locations = [];
let locCoords = {};
let dark = false;
let trashBin = [];
let currentTempImg = null;
let currentFilter = 'ALL';
let listExpanded = false; // Standardm√§√üig zugeklappt
let sortMode = 'fav'; 
let viewMode = 'list';
let isMuted = localStorage.getItem('muted') !== 'false';
let notifyConfig = JSON.parse(localStorage.getItem('notifyConfig')) || { enabled: false, days: 7 };
let undoStack = [];
let undoTimeout = null;
let mapInstance = null;
let tempImportData = null;
let detailAnimalIdx = null;

// KOMPAKT MODUS STATUS LADEN
let isCompact = localStorage.getItem('compactMode') === 'true';
if(isCompact) document.body.classList.add('compact-view');

function toggleCompactMode() {
    isCompact = !isCompact;
    localStorage.setItem('compactMode', isCompact);
    document.body.classList.toggle('compact-view', isCompact);
    render(); // Liste neu zeichnen, damit Abst√§nde passen
}

// LEVEL CONFIG
/* === NEUE LEVEL DEFINITION (4 WELTEN) === */
/* === NEUE LEVEL DEFINITION (5 TIER-ZONEN) === */
const levels = [
    // ZONE 1: GARTEN & WIESE (Der Anfang)
    { xp: 0, name: "Ameisen-Z√§hler" }, 
    { xp: 100, name: "Schmetterlings-Freund" }, 
    { xp: 300, name: "Spatzen-Beobachter" },
    { xp: 600, name: "Igel-Besch√ºtzer" }, 

    // ZONE 2: WALD & HEIMAT (Die Wildnis)
    { xp: 1000, name: "Eichh√∂rnchen-Sp√§her" },
    { xp: 1500, name: "Fuchs-F√§hrte" }, 
    { xp: 2200, name: "Eulen-Auge" }, 
    { xp: 3000, name: "Hirsch-W√§chter" }, 

    // ZONE 3: WASSER & MEER (Die Tiefe)
    { xp: 4000, name: "Teich-Frosch" }, 
    { xp: 5200, name: "Biber-Baumeister" }, 
    { xp: 6600, name: "Delfin-Schwimmer" }, 
    { xp: 8200, name: "Wal-Wanderer" }, 

    // ZONE 4: SAVANNE & DSCHUNGEL (Die Exoten)
    { xp: 10000, name: "Affen-Kletterer" }, 
    { xp: 12500, name: "Elefanten-Ged√§chtnis" }, 
    { xp: 15500, name: "Leoparden-Schleicher" }, 
    { xp: 19000, name: "L√∂wen-Herz" }, 

    // ZONE 5: APEX LEGENDEN (Die Spitze der Nahrungskette)
    { xp: 23000, name: "Adler-K√∂nig" }, 
    { xp: 28000, name: "B√§ren-Kraft" }, 
    { xp: 35000, name: "Wolfsrudel-Alpha" }, 
    { xp: 50000, name: "Meister der Wildnis" }
];

// Helper
const getEl = id => document.getElementById(id);
const todayStr = () => new Date().toISOString().slice(0,10);
const nowTimeStr = () => new Date().toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'});
function safeRun(fn, ...args){ try{fn(...args)}catch(e){console.error(e); showErrorToast(e.message)}}
function showErrorToast(msg, isInfo=false){
    const t=getEl('errorToast'); t.innerText=(isInfo?"‚ÑπÔ∏è ":"‚ö†Ô∏è ")+msg; 
    t.style.background=isInfo?"var(--accent)":"var(--err-bg)"; t.style.color=isInfo?"#fff":"var(--err-text)";
    t.style.display='block'; setTimeout(()=>t.style.display='none',4000);
}


// HELPER: Debounce f√ºr die Suche
let debounceTimer;
function debouncedRender() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
        render();
    }, 250);
}

function toggleMute(){ isMuted=!isMuted; localStorage.setItem('muted',isMuted); getEl('muteBtn').innerText=isMuted?'üîá':'üîä'; }

/* === HIER EINF√úGEN: RIPPLE EFFEKT LOGIK === */
 function createRipple(event) { const button = event.currentTarget; const circle = document.createElement("span"); const diameter = Math.max(button.clientWidth, button.clientHeight); const radius = diameter / 2; 
// Position berechnen 
const rect = button.getBoundingClientRect(); circle.style.width = circle.style.height = `${diameter}px`; circle.style.left = `${event.clientX - rect.left - radius}px`; circle.style.top = `${event.clientY - rect.top - radius}px`; circle.classList.add("ripple");
// Falls schon ein Ripple da ist, entfernen 
const ripple = button.getElementsByClassName("ripple")[0]; if (ripple) { ripple.remove(); } button.appendChild(circle); }
 /* === ENDE EINF√úGEN === */ 



// === 4. AUDIO ENGINE ===
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function playSound(type){
    if(isMuted) return;
    if(!audioCtx) audioCtx = new AudioContext();
    if(audioCtx.state==='suspended') audioCtx.resume();
    const now=audioCtx.currentTime; const osc=audioCtx.createOscillator(); const g=audioCtx.createGain();
    osc.connect(g); g.connect(audioCtx.destination);
    if(type==='pop'){
        osc.frequency.setValueAtTime(800,now); osc.frequency.exponentialRampToValueAtTime(1200,now+0.1);
        g.gain.setValueAtTime(0.05,now); g.gain.exponentialRampToValueAtTime(0.001,now+0.1);
        osc.start(now); osc.stop(now+0.1);
    } else if(type==='fanfare'){
        [440,554,659].forEach((f,i)=>{
             const o=audioCtx.createOscillator(); const gn=audioCtx.createGain(); o.connect(gn); gn.connect(audioCtx.destination);
             o.frequency.value=f; gn.gain.setValueAtTime(0.05,now+i*0.1); gn.gain.linearRampToValueAtTime(0,now+i*0.1+0.5);
             o.start(now+i*0.1); o.stop(now+i*0.1+0.5);
        });
    }
}

// === 5. DATA ENGINE ===
function getHistory(y) { try{return JSON.parse(localStorage.getItem('history-'+y))||{}}catch(e){return{}} }
function saveHistory(y, h) { localStorage.setItem('history-'+y, JSON.stringify(h)); }
function getAvailableYears() {
    let ys = new Set([currentSystemYear]);
    for(let i=0; i<localStorage.length; i++) {
        const k = localStorage.key(i);
        if(k.startsWith('history-')) ys.add(parseInt(k.split('-')[1]));
    }
    return Array.from(ys).sort((a,b)=>b-a);
}

function writeEntry(date, idx, data){
    const y = parseInt(date.split('-')[0]);
    let h = getHistory(y);
    h[date] = h[date] || { total:0, perAnimal:{} };
    h[date].perAnimal[idx] = h[date].perAnimal[idx] || [];
    h[date].perAnimal[idx].push(data);
    h[date].total++;
    saveHistory(y, h);
    return { year:y, date, idx, arrIdx: h[date].perAnimal[idx].length-1 };
}

function removeEntry(date, idx, arrIdx){
    const y = parseInt(date.split('-')[0]);
    let h = getHistory(y);
    if(h[date]?.perAnimal?.[idx]){
        h[date].perAnimal[idx].splice(arrIdx, 1);
        h[date].total--;
        if(h[date].perAnimal[idx].length===0) delete h[date].perAnimal[idx];
        if(h[date].total<=0) delete h[date];
        saveHistory(y, h);
    }
}

// === 30-TAGE CLEANUP ===
function checkTrashAge(){
    const now = Date.now();
    const limit = 30 * 24 * 60 * 60 * 1000; // 30 Tage in ms
    const initialLen = trashBin.length;
    
    // Behalte nur Elemente, die j√ºnger als 30 Tage sind (oder kein Datum haben -> Legacy Schutz)
    trashBin = trashBin.filter(item => {
        if(!item.deletedAt) return true; 
        return (now - item.deletedAt) < limit;
    });
    
    if(trashBin.length !== initialLen) {
        saveGlobals();
        console.log("Papierkorb automatisch bereinigt.");
    }
}

function loadGlobals(){
    try {
        // 1. Tiere laden
        const a = localStorage.getItem('animals-'+currentSystemYear) || localStorage.getItem('animals-'+(currentSystemYear-1));
        animals = a ? JSON.parse(a) : [];
        
        // Datenbank-Migration (optional, falls noch alte Bilder da sind)
        animals.forEach(async (an, i) => {
            if(an.image && !an.imageId && an.image.startsWith('data:')) {
                const newId = 'img_'+Date.now()+'_'+i;
                await dbSaveImg(newId, an.image);
                an.imageId = newId; delete an.image;
                saveGlobals();
            }
        });
        
        // 2. Orte laden
        locations = JSON.parse(localStorage.getItem('locations')||'[]');
        let lc = localStorage.getItem('locCoords');
        if(!lc) lc = localStorage.getItem('locCoords-'+currentSystemYear);
        locCoords = lc ? JSON.parse(lc) : {};

        // 3. PAPIERKORB LADEN (Das fehlte wahrscheinlich!)
        trashBin = JSON.parse(localStorage.getItem('trashBin') || '[]');

        // 4. Einstellungen
        dark = localStorage.getItem('darkmode')==='true';
        if(dark) document.body.classList.add('dark');
        viewMode = localStorage.getItem('viewMode') || 'list';
        sortMode = localStorage.getItem('sortMode') || 'fav';

        // 5. START-AKTIONEN
        // Automatisch alte Sachen l√∂schen (>30 Tage)
        if(typeof checkTrashAge === "function") checkTrashAge();
        
        // Anzeige sofort aktualisieren!
        updateStorageUI(); 
        updateTrashUI(); // <--- Sorgt daf√ºr, dass die Eintr√§ge sofort sichtbar sind
  
       checkBackupHealth();
       setTimeout(initMemoryDeck, 1000); // Kurz warten damit DB bereit ist

    } catch(e){ 
        console.error("Fehler beim Laden:", e); 
        // Falls was schief geht, nicht alles l√∂schen, nur Fehler loggen
        showErrorToast("Fehler beim Laden der Daten");
    }
}

function saveGlobals(){
    localStorage.setItem('animals-'+currentSystemYear, JSON.stringify(animals));
    localStorage.setItem('locations', JSON.stringify(locations));
    localStorage.setItem('locCoords', JSON.stringify(locCoords));
    localStorage.setItem('trashBin', JSON.stringify(trashBin));
}

async function updateStorageUI(){
    const count = await dbCount();
    getEl('storageText').innerText = count + " Bilder gespeichert";
    const pct = Math.min((count * 0.5) / 500 * 100, 100);
    getEl('storageBar').style.width = pct + '%';
    getEl('storageBar').style.background = pct > 90 ? 'var(--err-text)' : 'var(--accent)';
}

// === 6. IMAGE COMPRESSION ===
function resizeImage(base64, maxW, cb){
    const img = new Image();
    img.src = base64;
    img.onload = () => {
        const c = document.createElement('canvas');
        const scale = maxW / img.width;
        c.width = maxW;
        c.height = img.height * scale;
        const ctx = c.getContext('2d');
        ctx.drawImage(img, 0, 0, c.width, c.height);
        cb(c.toDataURL('image/jpeg', 0.6));
    };
}

// === 7. CORE LOGIC ===
async function addAnimal(){
    const nm = getEl('nameInput').value.trim();
    if(!nm) return showErrorToast("Name fehlt");
    let imgId = null;
    if(currentTempImg) {
        imgId = 'img_' + Date.now();
        await dbSaveImg(imgId, currentTempImg);
    }
    const tags = getEl('tagInput').value.trim() ? getEl('tagInput').value.split(',').map(s=>s.trim()) : [];
    animals.push({ name:nm, emoji:getEl('emojiInput').value||'üêæ', imageId: imgId, tags, isFav: false });
    getEl('nameInput').value=''; getEl('emojiInput').value=''; getEl('tagInput').value='';
    clearImage();
    saveGlobals(); render(); updateStorageUI();
    showErrorToast("Tier angelegt!", true);
}

function handleImageUpload(input){
    if(input.files && input.files[0]){
        const reader = new FileReader();
        reader.onload = e => resizeImage(e.target.result, 800, res => { // Max 800px width
            currentTempImg = res;
            getEl('previewEl').src = res;
            getEl('imgPreview').style.display='block';
        });
        reader.readAsDataURL(input.files[0]);
    }
}
function clearImage(){ currentTempImg=null; getEl('imgPreview').style.display='none'; }

// === UNDO SYSTEM ===
function showUndoToast(actionDesc, undoFn) {
    const t = getEl('undoToast');
    getEl('undoText').innerText = actionDesc;
    t.classList.add('show');
    clearTimeout(undoTimeout);
    undoStack.push(undoFn);
    undoTimeout = setTimeout(() => {
        t.classList.remove('show');
        undoStack = []; 
    }, 4000);
}

function performUndo() {
    if(undoStack.length > 0) {
        const fn = undoStack.pop(); fn();
        getEl('undoToast').classList.remove('show');
        render(); showErrorToast("R√ºckg√§ngig gemacht", true);
    }
}

function change(i, delta, e){
    if(delta > 0) {
        const locSel = getEl(viewMode === 'grid' ? 'locSelectGrid'+i : 'locSelect'+i);
        const locVal = locSel ? locSel.value : '';
        const entry = { location: locVal, time: nowTimeStr() };
        const date = todayStr();
        const info = writeEntry(date, i, entry);
        playSound('pop');
        if(e && navigator.vibrate) navigator.vibrate(15);
        if(e) spawnParticle(e.clientX, e.clientY, "+1");
        showUndoToast(`Gez√§hlt: ${animals[i].name} (+1)`, () => removeEntry(date, i, info.arrIdx));
        render();
    }
}

function toggleFav(i, e) {
    if(e) e.stopPropagation();
    animals[i].isFav = !animals[i].isFav;
    saveGlobals();
    if(navigator.vibrate) navigator.vibrate(5);
    render();
}

function spawnParticle(x, y, text) {
    const p = document.createElement('div');
    p.className = 'particle'; p.innerText = text; p.style.color = 'var(--accent)';
    p.style.left = x + 'px'; p.style.top = y + 'px';
    document.body.appendChild(p);
    setTimeout(() => p.remove(), 800);
}

// === FIX: EIGENE FUNKTION F√úR ORTE ===
function renderLocations() {
    const locContainer = document.getElementById('locationListDisplay');
    // Falls wir gerade nicht auf der Admin-Seite sind oder das Element fehlt
    if(!locContainer) return;

    locContainer.innerHTML = '';
    
    if(!locations.length) {
        locContainer.innerHTML = '<span style="font-size:13px; opacity:0.5; padding:5px;">Keine Orte gespeichert.</span>';
    } else {
        locations.forEach((l, i) => {
            const pill = document.createElement('div');
            pill.style.cssText = "background:var(--btn); padding:6px 10px; border-radius:15px; font-size:12px; cursor:pointer; display:flex; align-items:center; gap:5px; border:1px solid transparent;";
            pill.innerHTML = `<span>üìç ${l}</span> <span style="color:var(--err-text); font-weight:bold; margin-left:2px;">&times;</span>`;
            
            // WICHTIG: stopPropagation verhindert, dass Klicks auf das X irgendwas anderes ausl√∂sen
            pill.onclick = (e) => { 
                e.stopPropagation(); 
                safeRun(deleteLocation, i); 
            };
            
            locContainer.appendChild(pill);
        });
    }
}

// Hilfsfunktion um Fav-Counts zu berechnen
function favsWithCount(favArray, historyData) {
    return favArray.map(f => {
        let c = 0; 
        Object.values(historyData).forEach(day => { 
            if(day.perAnimal?.[f.idx]) c += day.perAnimal[f.idx].length; 
        });
        return {...f, count: c};
    });
}

/* === RENDER (LISTE, SNEAK PEEK & FAVORITEN) === */
function render() {
    // Orte Rendern (falls Funktion existiert)
    if(typeof renderLocations === 'function') renderLocations();

    // Elemente holen
    const list = document.getElementById('list'); 
    const favCont = document.getElementById('favContainer');
    const toggleCont = document.getElementById('listToggleContainer');
    const sneakCont = document.getElementById('sneakPeekContainer');
    const sneakHint = document.getElementById('sneakHint');
    const emptyState = document.getElementById('emptyState');
    
    // Alles leeren
    if(list) list.innerHTML = '';
    if(favCont) favCont.innerHTML = '';
    if(toggleCont) toggleCont.innerHTML = '';

    // Button Texte aktualisieren
    const viewBtn = document.getElementById('viewToggleBtn');
    const sortBtn = document.getElementById('sortBtn');
    if(viewBtn) viewBtn.innerText = viewMode === 'list' ? 'üìú' : '‚ñ¶';
    if(sortBtn) sortBtn.innerText = sortMode === 'fav' ? '‚≠ê' : (sortMode === 'name' ? 'üî§' : (sortMode === 'count' ? 'üî¢' : 'üïí'));

    const searchVal = document.getElementById('listSearch').value.toLowerCase();
    
    // Filter Tags Rendern
    const allTags = new Set(); 
    animals.forEach(a => a.tags?.forEach(t => allTags.add(t)));
    const tagCont = document.getElementById('tagFilterContainer');
    if(tagCont) {
        let tagHTML = `<div class="tag-pill ${currentFilter==='ALL'?'active':''}" onclick="safeRun(filterTags, 'ALL')" id="tag-ALL">Alle</div>`;
        allTags.forEach(t => tagHTML += `<div class="tag-pill ${currentFilter===t?'active':''}" onclick="safeRun(filterTags, '${t}')" id="tag-${t}">${t}</div>`);
        tagCont.innerHTML = tagHTML;
    }

    // Counts & LastSeen Logic
    const h = getHistory(currentSystemYear);
    const getLastSeen = (idx) => {
        const yData = getHistory(currentSystemYear); 
        let maxTime = 0;
        Object.entries(yData).forEach(([dateStr, d]) => {
            if(d.perAnimal && d.perAnimal[idx]) {
                const lastEntry = d.perAnimal[idx][d.perAnimal[idx].length-1];
                const timeStr = lastEntry.time || "00:00";
                const ts = new Date(dateStr + 'T' + timeStr).getTime();
                if(ts > maxTime) maxTime = ts;
            }
        });
        return maxTime;
    };

    // Liste filtern
// --- LISTE FILTERN (JETZT MIT DEEP SEARCH F√úR ORTE) ---
    let displayList = animals.map((a, i) => {
        let count = 0;
        Object.values(h).forEach(day => { if(day.perAnimal?.[i]) count += day.perAnimal[i].length; });
        return { ...a, idx: i, count };
    }).filter(a => {
        // 1. Tag Filter (wie gehabt)
        if(currentFilter !== 'ALL' && !a.tags?.includes(currentFilter)) return false;
        
        // 2. Suche (Name ODER Ort)
        if(searchVal) {
            // A) Passt der Name? (z.B. "Fuchs")
            const nameMatch = a.name.toLowerCase().includes(searchVal);
            
            // B) Passt ein Ort in der Historie? (z.B. "Wald")
            // Wir schauen in allen Tagen nach, ob dieses Tier (a.idx) dort einen Eintrag mit dem Ort hat
            const locMatch = Object.values(h).some(day => 
                day.perAnimal && 
                day.perAnimal[a.idx] && 
                day.perAnimal[a.idx].some(entry => 
                    entry.location && entry.location.toLowerCase().includes(searchVal)
                )
            );

            // Zeigen, wenn Name ODER Ort passt
            return nameMatch || locMatch;
        }
        
        return true;
    });


    // --- LOGIK: SNEAK PEEK & SICHTBARKEIT ---
    const isSearching = searchVal.length > 0 || currentFilter !== 'ALL';
    const isExpandedState = listExpanded || isSearching;

    // A) Sneak Peek Container Steuern
    if (sneakCont) {
        if (isExpandedState) {
            sneakCont.classList.remove('collapsed'); // Liste voll auf
            if(sneakHint) sneakHint.style.display = 'none';
        } else {
            sneakCont.classList.add('collapsed'); // Liste maskiert
            if(sneakHint) sneakHint.style.display = 'block';
        }
    }

    // B) Einklappen-Button (Nur wenn ausgeklappt und KEINE Suche)
    if (toggleCont && isExpandedState && !isSearching) {
        toggleCont.innerHTML = `
        <div class="list-toggle-btn is-open" onclick="safeRun(collapseList)">
            Liste einklappen <span class="arrow-icon">‚ñ≤</span>
        </div>`;
    }

    // C) Favoriten Container (Nur wenn NICHT ausgeklappt und NICHT gesucht wird)
    if (favCont) {
        if (!isExpandedState && !isSearching) {
            favCont.style.display = 'block'; // Anzeigen
            
            // Favoriten bef√ºllen
            const favs = animals.map((a,i)=>({...a, idx:i})).filter(a => a.isFav);
            const favsData = favsWithCount(favs, h);

            if(favsData.length > 0) {
                const favTitle = document.createElement('div');
                favTitle.className = 'fav-scroll-title fade-in';
                favTitle.style.textAlign = 'center'; 
                favTitle.innerText = '‚≠ê Schnellzugriff';
                favCont.appendChild(favTitle);

                const scrollWrapper = document.createElement('div');
                scrollWrapper.className = 'fav-scroll-container fade-in';
                
                favsData.forEach(f => {
                    const fCard = document.createElement('div');
                    fCard.className = 'fav-card';
                    const imgContainerId = `fav-img-${f.idx}`;
                    
                    fCard.innerHTML = `
                        <div class="fav-visual" id="${imgContainerId}">${f.emoji}</div>
                        <div class="fav-name">${f.name}</div>
                        <div class="fav-count">${f.count}</div>
                    `;
                    fCard.onclick = (event) => { safeRun(openDetail, f.idx); };
                    
                    if(f.imageId) {
                        dbGetImg(f.imageId).then(src => {
                            const el = document.getElementById(imgContainerId);
                            if(src && el) {
                                el.innerHTML = `<img src="${src}">`;
                                el.style.border = "1px solid var(--btn)"; 
                            }
                        });
                    }
                    scrollWrapper.appendChild(fCard);
                });
                favCont.appendChild(scrollWrapper);
            }
        } else {
            favCont.style.display = 'none'; // Verstecken
        }
    }

    // Floating Buttons
    const floatCtrl = document.getElementById('floatingControls');
    if(floatCtrl) {
        if (displayList.length > 0 || isSearching) floatCtrl.classList.add('visible'); 
        else floatCtrl.classList.remove('visible');       
    }

    // D) Liste bef√ºllen oder Empty State
    if(displayList.length === 0) {
        if(emptyState) emptyState.style.display = 'block';
        
        // Smart Create bei leerer Suche
        if(searchVal) {
            if(emptyState) emptyState.style.display = 'none';
            const div = document.createElement('div');
            div.style.textAlign = "center"; div.style.padding = "30px";
            div.innerHTML = `<div style="font-size:40px; margin-bottom:10px;">ü§∑‚Äç‚ôÇÔ∏è</div><div style="margin-bottom:15px; font-weight:bold;">"${getEl('listSearch').value}" nicht gefunden.</div><button onclick="safeRun(quickCreate, '${getEl('listSearch').value}')" style="background:var(--accent); color:#fff; padding:12px 20px; font-size:16px;">‚ö° Jetzt schnell anlegen</button>`;
            if(list) list.appendChild(div);
            if(sneakCont) sneakCont.classList.remove('collapsed'); 
        }
        return; 
    }
    
    if(emptyState) emptyState.style.display = 'none';

    // Sortierung
    displayList.sort((a,b) => {
        if(sortMode === 'fav') { 
            if (a.isFav && !b.isFav) return -1;
            if (!a.isFav && b.isFav) return 1;
            return a.name.localeCompare(b.name); 
        }
        if(sortMode === 'last') return getLastSeen(b.idx) - getLastSeen(a.idx);
        if(sortMode === 'name') return a.name.localeCompare(b.name);
        return b.count - a.count;
    });

    const highlightText = (text, query) => {
        if(!query) return text;
        const regex = new RegExp(`(${query})`, 'gi');
        return text.replace(regex, '<mark style="background:rgba(255,235,59,0.5); color:inherit; padding:0 2px; border-radius:2px;">$1</mark>');
    };


// --- GRID VIEW (IMMERSIVE) ---
// --- GRID VIEW (IMMERSIVE + MENU BOTTOM RIGHT) ---
    if (viewMode === 'grid') {
        const gridCont = document.createElement('div'); gridCont.className = 'grid-container';
        displayList.forEach((item, loopIdx) => {
            const card = document.createElement('div'); 
            card.className = 'grid-item fade-in';
            card.style.animationDelay = `${loopIdx * 0.04}s`; 
            
            // Klick auf ganze Karte √∂ffnet Details
            card.onclick = () => openDetail(item.idx);

            // Bild oder Emoji als Hintergrund
            let bgHTML = `<div class="grid-bg-img" style="background:var(--btn); display:flex; align-items:center; justify-content:center; font-size:60px;">${item.emoji}</div>`;
            
            // HTML Bauen
            card.innerHTML = `
                ${bgHTML}
                <div class="grid-overlay"></div>
                
                <!-- Z√§hler Oben Rechts -->
                <div class="grid-badge-top">${item.count}</div>
                
                <!-- Text unten links -->
                <div class="grid-info">
                    <div class="grid-name">${item.name}</div>
                    <div class="grid-sub">${item.isFav ? '‚≠ê Favorit' : (item.tags[0] || 'Tier')}</div>
                </div>
                
                <!-- MEN√ú BUTTON: Unten Rechts -->
                <div class="grid-menu-btn" onclick="openItemMenu(${item.idx}, event)">‚ãÆ</div>
            `;
            
            // Bild nachladen
            if(item.imageId) { 
                dbGetImg(item.imageId).then(src => { 
                    if(src) {
                        const oldBg = card.querySelector('.grid-bg-img');
                        if(oldBg) {
                            oldBg.innerHTML = ''; 
                            oldBg.style.background = 'transparent';
                            const img = document.createElement('img');
                            img.src = src; img.className = 'grid-bg-img';
                            oldBg.replaceWith(img);
                        }
                    }
                }); 
            }
            
            gridCont.appendChild(card);
        });
        list.appendChild(gridCont);
    }



    // --- LIST VIEW ---
    else {
displayList.forEach((item, loopIdx) => {
            const div = document.createElement('div'); 
            div.className = `row fade-in`;
            div.style.animationDelay = `${loopIdx * 0.05}s`; 

            // --- 1. SMART SUBTEXT (MIT DATUM) ---
            let subText = "";
            let timeIcon = "";
            
            // Wir filtern alle Tage dieses Jahres, an denen das Tier gesehen wurde
            // (Das ist performant genug f√ºr die Liste)
            const sightingDates = Object.keys(h).filter(d => h[d].perAnimal && h[d].perAnimal[item.idx]);
            
            if (sightingDates.length > 0) {
                // Sortieren: Neuestes Datum ganz nach vorne
                sightingDates.sort((a,b) => b.localeCompare(a));
                const lastDateISO = sightingDates[0]; // z.B. "2024-05-12"
                
                const todayKey = new Date().toISOString().slice(0,10);
                
                if (lastDateISO === todayKey) {
                    // WENN HEUTE
                    subText = `<span style="color:#4cd137; font-weight:bold;">Heute entdeckt!</span>`;
                    timeIcon = 'üî•'; 
                } else {
                    // WENN VERGANGENHEIT -> Datum formatieren (DD.MM.)
                    const [yr, mo, da] = lastDateISO.split('-');
                    subText = `Zuletzt: ${da}.${mo}.`;
                    timeIcon = 'üìÖ'; 
                }
            } else {
                // WENN NOCH NIE GESEHEN -> Fallback auf Kategorie       
                    subText = "Noch nie gesehen";
                    timeIcon = 'üåë';          
            }

            // --- 2. DYNAMISCHE FARBE F√úR EMOJI-HINTERGRUND ---
            const colors = ['#e84393', '#0984e3', '#00b894', '#fdcb6e', '#6c5ce7', '#d63031'];
            const colorIdx = item.name.length % colors.length;
            const itemColor = colors[colorIdx];
            
            // Placeholder HTML
            let imgHTML = `
                <div class="list-thumb-placeholder" style="background: ${itemColor}20; color: ${itemColor}; border: 1px solid ${itemColor}40;">
                    ${item.emoji}
                </div>`;

            // --- 3. HTML BAUEN ---
            div.innerHTML = `
                <!-- ZONE 1: Hauptbereich -->
                <div class="row-main" onclick="openDetail(${item.idx})">
                    
                    <!-- BILD / ICON -->
                    <div class="list-visual">
                        ${imgHTML}
                    </div>

                    <!-- TEXT INFO -->
                    <div class="list-content">
                        <div class="list-top-line">
                            <span class="list-name">${item.name}</span>
                            ${item.isFav ? '<span class="list-fav-star">‚òÖ</span>' : ''}
                        </div>
                        <div class="list-sub-line">
                            <span style="font-size:14px; margin-right:6px;">${timeIcon}</span> 
                            <span>${subText}</span>
                        </div>
                    </div>
                    
                    <!-- Z√ÑHLER -->
                    <div class="count-badge"><span>${item.count}</span></div>
                </div>

                <!-- ZONE 2: Men√º -->
                <div class="row-menu" onclick="openItemMenu(${item.idx}, event)">‚ãÆ</div>
            `;
            
            // Bild nachladen
            if(item.imageId) { 
                dbGetImg(item.imageId).then(src => { 
                    if(src) {
                        const visualDiv = div.querySelector('.list-visual');
                        if(visualDiv) visualDiv.innerHTML = `<img src="${src}" class="list-thumb-img">`;
                    }
                }); 
            }
            
            list.appendChild(div);
        });
    }
}
function filterTags(t) { currentFilter=t; render(); }
function cycleSort() { 
    // Reihenfolge: Fav -> Zeit (Last) -> Name -> Anzahl -> Fav...
    if(sortMode === 'fav') sortMode = 'last';
    else if(sortMode === 'last') sortMode = 'name';
    else if(sortMode === 'name') sortMode = 'count';
    else sortMode = 'fav'; // Fallback & Reset auf Fav
    
    // Kleines Feedback (optional)
    // if(navigator.vibrate) navigator.vibrate(5);
    
    render(); 
}
function toggleViewMode() { viewMode = viewMode==='list'?'grid':'list'; localStorage.setItem('viewMode',viewMode); render(); }

// === DETAILS & EDIT ===

/* === OPEN DETAIL (CINEMATIC + 3 PUNKTE) === */
async function openDetail(i) {
    detailAnimalIdx = i; 
    const modal = getEl('detailModal');
    const a = animals[i];
    
    // 1. Bild aus DB laden (f√ºr Hintergrund & Icon)
    let bgStyle = '';
    let imgSrc = '';
    
    if (a.imageId) {
        try {
            const src = await dbGetImg(a.imageId);
            if (src) {
                imgSrc = src;
                // Hintergrund mit Blur und Abdunklung
                bgStyle = `background-image: linear-gradient(to bottom, rgba(0,0,0,0.2), rgba(0,0,0,0.8)), url('${src}');`;
            }
        } catch (e) {
            console.log("Bild konnte nicht geladen werden", e);
        }
    }

    // 2. HTML f√ºr den Header bauen
    const headerHTML = `
    <div class="detail-header-wrapper">
        <!-- Blur Hintergrund -->
        <div class="detail-bg-blur" style="${bgStyle}"></div>
        
        <div class="detail-header-content">
            <!-- Das Icon/Bild -->
            <div style="width:70px; height:70px; font-size:40px; border-radius:20px; overflow:hidden; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.3); border:2px solid rgba(255,255,255,0.2); box-shadow:0 5px 15px rgba(0,0,0,0.3); flex-shrink:0;">
                ${imgSrc ? 
                    `<img src="${imgSrc}" style="width:100%; height:100%; object-fit:cover; cursor:zoom-in;" onclick="openImageLightbox('${imgSrc}')">` : 
                    a.emoji
                }
            </div>
            
            <!-- Titel & Buttons -->
            <div style="flex:1;">
                <h2 style="margin:0; font-size:24px; color:#fff; text-shadow:0 2px 10px rgba(0,0,0,0.5); line-height:1.2;">${a.name}</h2>
                
                <div style="display:flex; align-items:center; gap:10px; margin-top:10px;">
                    <!-- 1. Quick Add Button (Blaues Plus) -->
                    <button onclick="openNoteModal(${i})" class="action-btn-main" style="width:38px; height:38px; font-size:20px; margin:0;" title="Sichtung hinzuf√ºgen">+</button>

                    <!-- 2. Men√º Button (Drei Punkte, Glassy Look) -->
                    <button onclick="openAnimalMenu(${i}, event)" 
                            style="width:38px; height:38px; font-size:22px; background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.3); color:#fff; border-radius:12px; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(5px); cursor:pointer;" 
                            title="Optionen">
                        ‚ãÆ
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Jahr Auswahl -->
    <div style="padding:0 5px; margin-top:-10px; position:relative; z-index:2;">
        <select id="detailYearSelect" onchange="safeRun(updateDetailChart)" style="padding:6px 12px; font-size:12px; background:var(--card); border:1px solid var(--btn); color:var(--sub); border-radius:12px; font-weight:bold; box-shadow:0 4px 10px rgba(0,0,0,0.1); cursor:pointer; outline:none;">
            <!-- Wird unten gef√ºllt -->
        </select>
    </div>
    `;
    
    // 3. In Modal einf√ºgen
    const modalContent = modal.querySelector('.modal-content');
    
    // Container suchen oder erstellen
    let container = document.getElementById('detail-dynamic-header');
    if (!container) {
        container = document.createElement('div');
        container.id = 'detail-dynamic-header';
        
        const closeBtn = modalContent.querySelector('.close-btn');
        if (closeBtn) {
            closeBtn.parentNode.insertBefore(container, closeBtn.nextSibling);
            // Close Button Styling anpassen (damit er auf dem Bild sichtbar ist)
            closeBtn.style.background = "rgba(0,0,0,0.5)";
            closeBtn.style.color = "#fff";
            closeBtn.style.border = "1px solid rgba(255,255,255,0.3)";
        } else {
            modalContent.prepend(container);
        }
        
        // Alte Elemente verstecken
        const oldTitle = document.getElementById('detailTitle');
        if (oldTitle) {
            const oldHeaderContainer = oldTitle.closest('div[style*="display:flex"]'); 
            if (oldHeaderContainer) oldHeaderContainer.style.display = 'none';
        }
    }
    
    container.innerHTML = headerHTML;

    // 4. Dropdown f√ºllen
    const ys = getAvailableYears();
    const sel = document.getElementById('detailYearSelect');
    if (sel) {
        sel.innerHTML = ys.map(y => `<option value="${y}" ${y===currentSystemYear?'selected':''}>üìÖ Jahr ${y}</option>`).join('');
    }
    
    // 5. Statistik laden
    updateDetailChart();
    modal.style.display = 'block';
}

// === DETAIL DASHBOARD LOGIK ===
/* === UPDATE DETAIL CHART (Separater Verlauf) === */
/* === UPDATE DETAIL CHART (REPARIERT) === */
function updateDetailChart() {
    const i = detailAnimalIdx; 
    const y = parseInt(getEl('detailYearSelect').value);
    const h = getHistory(y);
    const body = getEl('modalBody');
    const a = animals[i];
    if(!a) return;

    // --- 1. DATEN SAMMELN ---
    let total = 0;
    let locs = {};
    let allEntries = [];
    let firstDate = null;
    let maxDayCount = 0;
    let dailyCounts = {};

    Object.entries(h).forEach(([dateStr, entry]) => {
        if(entry.perAnimal?.[i]){
            const list = entry.perAnimal[i];
            total += list.length;
            
            // Tagesrekord & DNA Daten
            if(!dailyCounts[dateStr]) dailyCounts[dateStr] = 0;
            dailyCounts[dateStr] += list.length;
            
            // Erster Eintrag
            if(!firstDate || dateStr < firstDate) firstDate = dateStr;

            list.forEach((item, arrIdx) => {
                allEntries.push({ date:dateStr, item, arrIdx });
                if(item.location) locs[item.location] = (locs[item.location]||0)+1;
            });
        }
    });
    
    // Sortieren (Neu nach Alt)
    allEntries.sort((a,b) => b.date.localeCompare(a.date) || (b.item.time||'').localeCompare(a.item.time||''));
    maxDayCount = Math.max(...Object.values(dailyCounts), 0);
    const sortedLocs = Object.entries(locs).sort((a,b)=>b[1]-a[1]);

    // --- 2. VERLAUF LISTE GENERIEREN ---
    let historyHTML = '';
    if(allEntries.length === 0) {
        historyHTML = '<div style="opacity:0.5; text-align:center; padding:20px;">Noch keine Sichtungen.</div>';
    } else {
        let lastDate = '';
        const today = new Date().toISOString().slice(0,10);

        allEntries.forEach(row => {
            if(row.date !== lastDate) {
                let displayDate = row.date.split('-').reverse().slice(0,2).join('.');
                if(row.date === today) displayDate = "Heute";
                historyHTML += `<div style="margin:15px 0 5px 5px; font-size:11px; font-weight:bold; opacity:0.6; text-transform:uppercase; letter-spacing:1px;">üìÖ ${displayDate}</div>`;
                lastDate = row.date;
            }

            historyHTML += `
            <div class="row" style="min-height:50px; margin-bottom:8px; align-items: stretch; background:var(--card-solid); border:1px solid var(--btn);">
                <div class="row-main" style="cursor: default; display:flex; flex-direction:column; justify-content:center; align-items:flex-start; text-align:left; padding:10px 0 10px 15px;" onclick="event.stopPropagation()">
                    <div style="display:flex; align-items:center; gap:15px; flex-wrap:wrap;">
                        <span style="font-weight:bold; opacity:0.9; font-size:15px; white-space:nowrap;">‚åö ${row.item.time||'--:--'}</span>
                        ${row.item.location ? `<span style="font-size:14px; opacity:0.8; display:flex; align-items:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">üìç ${row.item.location}</span>` : ''}
                    </div>
                    ${row.item.note ? `<div style="font-size:13px; font-style:italic; background:rgba(0,0,0,0.05); color:var(--text); padding:6px 8px; border-radius:8px; margin-top:6px; line-height:1.4; text-align:left;">üìù ‚Äû${row.item.note}‚Äú</div>` : ''}
                </div>
                <div class="row-deadzone" onclick="event.stopPropagation()"></div>
                <div class="row-menu" onclick="openHistoryMenu(${i}, '${row.date}', ${row.arrIdx}, event)">‚ãÆ</div>
            </div>`;
        });
    }

    // --- 3. BERECHNUNGEN (Ranking, DNA etc.) ---
    const favLoc = sortedLocs.length > 0 ? `${sortedLocs[0][0]} (${sortedLocs[0][1]}x)` : '-';
    const myCat = (a.tags && a.tags.length > 0) ? a.tags[0] : 'Sonstige';
    
    let catRanking = [];
    animals.forEach((anim, idx) => {
        if((anim.tags && anim.tags.includes(myCat)) || (myCat==='Sonstige' && (!anim.tags || anim.tags.length===0))) {
            let c = 0; Object.values(h).forEach(d => { if(d.perAnimal?.[idx]) c += d.perAnimal[idx].length; });
            catRanking.push({ name: anim.name, count: c, isMe: (idx === i) });
        }
    });
    catRanking.sort((a,b) => b.count - a.count);
    
    // WICHTIG: Hier war der Fehler! Diese Funktion (getDOY) fehlte vorher:
    const getDOY = (dStr) => { 
        const now = new Date(dStr); 
        const start = new Date(now.getFullYear(), 0, 0); 
        return Math.floor((now - start) / (1000 * 60 * 60 * 24)); 
    };

    // Saison Logik
    const getSeason = (month) => {
        if(month <= 1 || month === 11) return 'Winter ‚ùÑÔ∏è';
        if(month >= 2 && month <= 4) return 'Fr√ºhling üå±';
        if(month >= 5 && month <= 7) return 'Sommer ‚òÄÔ∏è';
        return 'Herbst üçÇ';
    };
    let monthCounts = new Array(12).fill(0);
    allEntries.forEach(e => monthCounts[new Date(e.date).getMonth()]++);
    const bestMonthIdx = monthCounts.indexOf(Math.max(...monthCounts));
    const bestSeason = getSeason(bestMonthIdx);

    // Seltenheit
    let globalTotal = 0; Object.values(h).forEach(d => globalTotal += d.total);
    const rarityPct = globalTotal > 0 ? Math.round((total / globalTotal) * 100) : 0;
    
    let rarityLabel = "H√§ufig";
    let rarityDesc = "Du siehst dieses Tier st√§ndig.";
    if(rarityPct <= 1) { rarityLabel = "Legend√§r"; rarityDesc = "Ein echter Geist! Extrem selten."; }
    else if(rarityPct <= 5) { rarityLabel = "Episch"; rarityDesc = "Eine besondere Begegnung."; }
    else if(rarityPct <= 15) { rarityLabel = "Selten"; rarityDesc = "Man braucht etwas Gl√ºck."; }
    else if(rarityPct <= 30) { rarityLabel = "Ungew√∂hnlich"; rarityDesc = "Ab und zu zu sehen."; }
    
    // Timeline Events
    let timelineEvents = [];
    if (allEntries.length > 0) {
        const first = allEntries[allEntries.length-1]; 
        timelineEvents.push({ icon: 'üå±', title: 'Erste Begegnung', date: first.date, desc: first.item.location ? `Entdeckt in: ${first.item.location}` : 'Der Start deiner Beobachtungen.' });
    }
    if (maxDayCount > 2) {
        const recordDateStr = Object.keys(dailyCounts).find(key => dailyCounts[key] === maxDayCount);
        timelineEvents.push({ icon: 'üî•', title: 'Rekord-Tag', date: recordDateStr, desc: `Unglaubliche ${maxDayCount} Sichtungen an einem einzigen Tag!` });
    }
    if (allEntries.length > 1) {
        const last = allEntries[0];
        timelineEvents.push({ icon: 'üìç', title: 'Zuletzt gesehen', date: last.date, desc: last.item.note ? `Notiz: "${last.item.note}"` : (last.item.location ? `Ort: ${last.item.location}` : 'Keine Details eingetragen.') });
    }
    timelineEvents.sort((a,b) => a.date.localeCompare(b.date));


    // --- 4. HTML GENERIEREN ---
    let html = `
    <!-- HEADER -->
    <div class="stats-grid" style="margin-bottom:20px;">
        <div class="stat-card">
            <div class="stat-label">Gesamt ${y}</div>
            <div class="stat-value bump-effect" id="stat-total">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Tages-Rekord</div>
            <div class="stat-value" id="stat-record">0</div>
        </div>
    </div>

    <!-- STAT WIDGET -->
    <div class="stat-widget-wrapper">
        <div class="widget-header">
            <span class="widget-label">Analyse:</span>
            <select class="stat-selector" onchange="switchStat(this.value)">
                <option value="highlights">üìù Highlights</option>
                <option value="ranking">üèÜ Rang (${myCat})</option>
                <option value="locations">üìç Top Orte</option>
                <option value="memory">üí≠ Notizen</option>
                <option value="timeline">‚è≥ Meilensteine</option>
                <option value="dna">üß¨ Jahres-DNA</option>
                <option value="rarity">üíé Seltenheit</option>
            </select>
        </div>
<!-- 1. HIGHLIGHTS -->
        <div id="highlights" class="stat-content active">
            <div class="grid-stats">
                <!-- HIER GE√ÑNDERT: stat-grid-item statt grid-item -->
                <div class="stat-grid-item">
                    <div class="gi-icon">üìÖ</div>
                    <div class="gi-label">Erste Sichtung</div>
                    <div class="gi-val">${firstDate ? firstDate.split('-').reverse().join('.') : '-'}</div>
                </div>
                
                <div class="stat-grid-item">
                    <div class="gi-icon">üî•</div>
                    <div class="gi-label">Rekord</div>
                    <div class="gi-val gi-highlight">${maxDayCount} an einem Tag</div>
                </div>
                
                <!-- Die breite Kachel unten -->
                <div class="stat-grid-item" style="grid-column: span 2; flex-direction: row; align-items: center; gap: 15px;">
                    <div class="gi-icon" style="font-size:24px;">üìç</div>
                    <div>
                        <div class="gi-label">Lieblingsort</div>
                        <div class="gi-val">${favLoc}</div>
                    </div>
                </div>
            </div>
        </div>
     
        <div id="locations" class="stat-content">
            <div style="margin-top:10px">
                ${sortedLocs.length===0?'<div style="opacity:0.5;text-align:center">Leer</div>':''}
                ${sortedLocs.slice(0,5).map((l,i)=>`<div class="loc-info"><strong>${l[0]}</strong><span>${l[1]}x</span></div><div class="loc-row"><div class="loc-rank ${i===0?'gold':''}">${i+1}</div><div class="loc-bar-bg"><div class="loc-bar-fill" style="width:${(l[1]/sortedLocs[0][1])*100}%"></div></div></div>`).join('')}
            </div>
        </div>

        <div id="ranking" class="stat-content">
            <div class="ranking-list">
                ${catRanking.slice(0,5).map((r,i)=>`<div class="rank-row ${r.isMe?'me':''}"><div class="r-pos" style="${r.isMe?'color:var(--accent)':''}">${i+1}</div><div class="r-name">${r.name} ${r.isMe?'':''}</div><div class="r-count" style="${r.isMe?'background:var(--accent);color:#fff':''}">${r.count}x</div></div>`).join('')}
            </div>
        </div>

     
<div id="memory" class="stat-content">
            <div class="mem-scroll">
                ${allEntries.filter(e => e.item.note).length === 0 ? '<div style="opacity:0.5; padding:20px;">Keine Notizen vorhanden.</div>' : ''}
                
                ${allEntries.filter(e => e.item.note).map((e, idx) => `
                <div class="mem-card" 
                     onclick="viewNoteDetail(${i}, '${e.date}', ${e.arrIdx})"
                     style="transform: rotate(${idx % 2 === 0 ? '-2' : '2'}deg);"> 
                     
                    <div class="mem-date">${e.date.split('-').reverse().slice(0,2).join('.')}</div>
                    <div class="mem-txt">"${e.item.note}"</div>
                    
                    <div style="position:absolute; bottom:-5px; right:-5px; font-size:40px; opacity:0.1; pointer-events:none;">${a.emoji}</div>
                </div>
                `).join('')}
            </div>
        </div>

        <div id="timeline" class="stat-content">
            <div class="timeline-container">
                <div class="timeline-line"></div>
                ${timelineEvents.map(evt => `
                <div class="tl-event">
                    <div class="tl-icon-bubble">${evt.icon}</div>
                    <div class="tl-content">
                        <div class="tl-date">${evt.date.split('-').reverse().join('.')}</div>
                        <div class="tl-title">${evt.title}</div>
                        <div class="tl-desc">${evt.desc}</div>
                    </div>
                </div>
                `).join('')}
                ${timelineEvents.length === 0 ? '<div style="padding-left:20px; opacity:0.5">Sammle mehr Daten f√ºr eine Timeline.</div>' : ''}
            </div>
        </div>

        <div id="dna" class="stat-content">
            <div class="dna-wrapper">
                <div class="dna-track">
                    ${Object.keys(dailyCounts).map(dStr=>`<div class="dna-mark" style="left:${(getDOY(dStr)/366)*100}%"></div>`).join('')}
                </div>
                <div class="dna-axis">
                    <span class="dna-tick">J</span><span class="dna-tick">F</span><span class="dna-tick">M</span><span class="dna-tick">A</span>
                    <span class="dna-tick">M</span><span class="dna-tick">J</span><span class="dna-tick">J</span><span class="dna-tick">A</span>
                    <span class="dna-tick">S</span><span class="dna-tick">O</span><span class="dna-tick">N</span><span class="dna-tick">D</span>
                </div>
                ${total > 0 ? `<div class="dna-insight">üí° Hauptsaison: ${bestSeason}</div>` : ''}
            </div>
        </div>

        <div id="rarity" class="stat-content">
            <div class="rarity-wrapper">
                <div class="rarity-scale-line">
                    <div class="rarity-pointer" style="left:${rarityPct}%">
                        <div class="rarity-flag">${rarityLabel} (${rarityPct}%)</div>
                        <div class="rarity-triangle"></div>
                    </div>
                </div>
                <div class="rarity-labels"><span>Gew√∂hnlich</span><span>Selten</span></div>
                <div style="text-align:center; font-size:13px; margin-top:20px; line-height:1.5; opacity:0.9">${rarityDesc}</div>
            </div>
        </div>
    </div>

    <!-- SEPARATER VERLAUF (AKKORDEON) -->
    <div class="history-section">
        <div class="history-toggle-btn" onclick="toggleHistory(this)">
            <span>üìã Verlauf anzeigen (${allEntries.length})</span>
            <span class="history-arrow">‚ñº</span>
        </div>
        <div class="history-container-wrapper">
            <div class="history-inner">
                <div class="history-scroll-area">
                    ${historyHTML}
                </div>
            </div>
        </div>
    </div>

    <!-- DELETE -->
    <div style="margin-top:20px; text-align:center;">
        <button onclick="safeRun(moveToTrash, ${i})" style="width:100%; background:var(--err-bg); color:var(--err-text); border:1px solid var(--err-text); padding:14px; border-radius:16px; font-weight:bold;">üóëÔ∏è Tier entfernen</button>
    </div>
    `;
    
    body.innerHTML = html;
    
    setTimeout(() => {
        if(typeof animateValue === 'function') {
            animateValue(document.getElementById('stat-total'), 0, total, 1000);
            animateValue(document.getElementById('stat-record'), 0, maxDayCount, 1200);
        } else {
            document.getElementById('stat-total').innerHTML = total;
            document.getElementById('stat-record').innerHTML = maxDayCount;
        }
    }, 100);
}

// Helper f√ºr das History Men√º
function openHistoryMenu(idx, date, arrIdx, event) {
    if(event) event.stopPropagation();
    
    const menuItems = [
        { label: 'Bearbeiten', icon: '‚úèÔ∏è', action: `openNoteModal(${idx}, '${date}', ${arrIdx})` },
        { label: 'L√∂schen', icon: 'üóëÔ∏è', action: `deleteHistoryItem('${date}', ${idx}, ${arrIdx})`, danger: true }
    ];
    
    // Position (Touch/Maus)
    let x = event.clientX || (event.touches ? event.touches[0].clientX : 0);
    let y = event.clientY || (event.touches ? event.touches[0].clientY : 0);
    
    // Fallback
    if(x === 0 && y === 0) { 
        const rect = event.target.getBoundingClientRect();
        x = rect.left; y = rect.bottom;
    }

    openContextMenu(x, y, menuItems);
}
// === PAPIERKORB LOGIK (TIERE & EINTR√ÑGE) ===

// 1. Einzelnen Eintrag l√∂schen -> in Papierkorb
function deleteHistoryItem(date, i, idx) { 
    if(confirm("Eintrag in Papierkorb verschieben?")) { 
        const h = getHistory(parseInt(date.split('-')[0]));
        const entry = h[date].perAnimal[i][idx];
        
        trashBin.push({
            type: 'entry',
            name: animals[i].name, // F√ºr Anzeige
            date: date,
            animalIdx: i,
            data: entry,
            deletedAt: Date.now()
        });
        
        removeEntry(date, i, idx); 
        saveGlobals(); 
        updateTrashUI();
        updateDetailChart(); 
        render(); 
        showErrorToast("In Papierkorb verschoben", true);
    } 
}

 // 2. Ganzes Tier l√∂schen -> in Papierkorb (INKLUSIVE HISTORIE & INDEX-KORREKTUR)
function moveToTrash(i){ 
    const tierName = animals[i].name;
    if(!confirm(`M√∂chtest du "${tierName}" wirklich l√∂schen?\n\nDas Tier UND alle seine ${animals[i].count||0} Eintr√§ge landen im Papierkorb.`)) {
        return; 
    }

    // A) Historie sichern (Alle Jahre durchgehen)
    const archivedHistory = {}; 
    const years = getAvailableYears();
    
    years.forEach(y => {
        const h = getHistory(y);
        let hasData = false;
        
        Object.entries(h).forEach(([dateStr, dayData]) => {
            if(dayData.perAnimal && dayData.perAnimal[i]) {
                if(!archivedHistory[y]) archivedHistory[y] = {};
                // Wir speichern Datum -> Array von Eintr√§gen
                archivedHistory[y][dateStr] = dayData.perAnimal[i]; 
                hasData = true;
            }
        });
    });

    // B) In Papierkorb schieben (Tier + Historie)
    trashBin.push({
        type: 'animal',
        data: { ...animals[i] }, 
        history: archivedHistory, // Das ist NEU: Die kompletten Sichtungen
        name: tierName,
        deletedAt: Date.now()
    });
    
    // C) Historie der verbleibenden Tiere korrigieren (Index-Shift)
    // Wenn wir Tier 2 l√∂schen, wird Tier 3 zu Tier 2. Die Historie muss das auch tun!
    years.forEach(y => {
        const h = getHistory(y);
        let changed = false;
        
        Object.values(h).forEach(dayData => {
            if(!dayData.perAnimal) return;
            
            // 1. Eintrag des gel√∂schten Tiers entfernen
            if(dayData.perAnimal[i]) { delete dayData.perAnimal[i]; changed = true; }
            
            // 2. Alle Indices > i um eins verringern
            // Wir m√ºssen hier vorsichtig sein und eine neue Map aufbauen oder Schl√ºssel verschieben
            const newPerAnimal = {};
            Object.keys(dayData.perAnimal).forEach(k => {
                const idx = parseInt(k);
                if(idx < i) {
                    newPerAnimal[idx] = dayData.perAnimal[idx]; // Bleibt gleich
                } else if (idx > i) {
                    newPerAnimal[idx - 1] = dayData.perAnimal[idx]; // Rutscht eins runter
                    changed = true;
                }
            });
            dayData.perAnimal = newPerAnimal;
        });
        
        if(changed) saveHistory(y, h);
    });

    // D) Tier aus Array entfernen
    animals.splice(i, 1); 
    
    saveGlobals(); 
    render(); 
    updateStorageUI(); 
    updateTrashUI(); 
    closeModal('detailModal'); 
    showErrorToast("In Papierkorb verschoben", true); 
}


// 3. Wiederherstellen (Tier inkl. Historie)
function restoreFromTrash(trashIdx){ 
    const item = trashBin[trashIdx];
    
    if(item.type === 'entry') {
        // Einzelner Eintrag
        writeEntry(item.date, item.animalIdx, item.data);
        showErrorToast("Eintrag wiederhergestellt", true);
    } else {
        // KOMPLETTES TIER
        const animalData = item.data || item; // Fallback f√ºr alte Backups
        
        // 1. Tier wieder ans Ende der Liste anf√ºgen
        animals.push(animalData);
        const newIdx = animals.length - 1; // Das ist der neue Index
        
        // 2. Historie wiederherstellen (falls vorhanden)
        if(item.history) {
            Object.entries(item.history).forEach(([yearStr, datesObj]) => {
                const y = parseInt(yearStr);
                const h = getHistory(y);
                
                Object.entries(datesObj).forEach(([dateStr, entriesArr]) => {
                    // Tag initialisieren falls nicht da
                    h[dateStr] = h[dateStr] || { total:0, perAnimal:{} };
                    h[dateStr].perAnimal[newIdx] = entriesArr; // Hier mit NEUEM Index einf√ºgen
                    h[dateStr].total += entriesArr.length;
                });
                
                saveHistory(y, h);
            });
        }
        
        showErrorToast("Tier & Verlauf wiederhergestellt", true);
    }
    
    trashBin.splice(trashIdx, 1); 
    saveGlobals(); 
    render(); 
    
    // Falls Detailansicht offen war, aktualisieren
    if(getEl('detailModal').style.display === 'block') {
        // Wir m√ºssen das Modal schlie√üen, da sich der Index ge√§ndert hat!
        closeModal('detailModal');
    }
    
    updateStorageUI(); 
}

// 4. Papierkorb leeren	
function emptyTrash(){ 
    if(confirm("Papierkorb unwiderruflich leeren?")){ 
        trashBin = []; 
        saveGlobals(); 
        updateTrashUI(); 
        showErrorToast("Papierkorb geleert", true);
    } 
}

// 5. Papierkorb Eintrag Detailansicht
let currentTrashIdx = null;

function openTrashDetail(i) {
    currentTrashIdx = i;
    const item = trashBin[i];
    const m = getEl('trashDetailModal');
    
    // F√ºlle Daten
    getEl('tdName').innerText = item.name || 'Unbekannt';
    
    if (item.type === 'entry') {
        // --- EINZELNER EINTRAG ---
        getEl('tdType').innerHTML = 'üìù Einzelner Eintrag';
        getEl('tdDate').innerText = item.date;
        getEl('tdTime').innerText = item.data.time || '-';
        getEl('tdLoc').innerText = item.data.location || '-';
        getEl('tdNote').innerText = item.data.note || 'Keine Notiz';
        getEl('tdNote').style.display = 'block';
    } else {
        // --- KOMPLETTES TIER ---
        // Wir z√§hlen mal schnell nach, wie viele Eintr√§ge im Backup stecken
        let countArchived = 0;
        if(item.history) {
            Object.values(item.history).forEach(yearObj => {
                Object.values(yearObj).forEach(dayList => {
                    countArchived += dayList.length;
                });
            });
        }

        // Anzeige mit Z√§hler
        getEl('tdType').innerHTML = `üêæ Komplettes Tier <br><small style="color:var(--accent)">(${countArchived} Sichtungen archiviert)</small>`;
        getEl('tdDate').innerText = new Date(item.deletedAt).toLocaleDateString();
        getEl('tdTime').innerText = '-';
        getEl('tdLoc').innerText = '-';
        getEl('tdNote').style.display = 'none';
    }
    
    // Button Logik
    getEl('tdRestoreBtn').onclick = function() {
        restoreFromTrash(currentTrashIdx);
        closeModal('trashDetailModal');
    };

    m.style.display = 'block';
}

function updateTrashUI(){ 
    const t = getEl('trashList'); 
    const section = getEl('trashSection');
    const emptyBtn = section.querySelector('button'); // Den Button finden
    
    t.innerHTML = ''; // Liste leeren
    
    // WICHTIG: Die Bubble immer sichtbar machen (falls noch hidden gesetzt war)
    section.classList.remove('hidden');

    // FALL 1: Papierkorb ist leer
    if(trashBin.length === 0) {
        t.innerHTML = '<div style="padding:20px; text-align:center; opacity:0.6; font-size:13px; font-style:italic;">üóëÔ∏è Nichts im Papierkorb.<br>Alles sauber!</div>';
        if(emptyBtn) emptyBtn.style.display = 'none'; // Button verstecken
        return;
    }
    
    // FALL 2: Papierkorb hat Inhalt -> Button zeigen
    if(emptyBtn) emptyBtn.style.display = 'block';

    // Hilfsfunktion Zeilen-Erstellung
    const createTrashRow = (item, i) => {
        const daysLeft = item.deletedAt ? Math.ceil((30 * 86400000 - (Date.now() - item.deletedAt)) / 86400000) : 30;
        let info = item.type === 'entry' ? `${item.date}` : 'Tier';
        
        return `
        <div onclick="safeRun(openTrashDetail, ${i})" style="display:flex; justify-content:space-between; align-items:center; padding:12px; border-bottom:1px solid var(--btn); cursor:pointer; transition:background 0.2s;" onmouseover="this.style.background='var(--btn)'" onmouseout="this.style.background='transparent'">
            <div style="overflow:hidden;">
                <div style="font-weight:bold; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                    ${item.type==='entry'?'üìù':'üêæ'} ${item.name}
                </div>
                <div style="font-size:11px; opacity:0.7">
                    ${info} ‚Ä¢ noch ${daysLeft} Tage
                </div>
            </div>
            <span style="font-size:18px; color:var(--accent)">‚ÑπÔ∏è</span>
        </div>`;
    };

    // Die ersten 2 Eintr√§ge
    trashBin.slice(0, 2).forEach((item, i) => {
        t.innerHTML += createTrashRow(item, i);
    });

    // Accordion f√ºr den Rest
    if (trashBin.length > 2) {
        let hiddenRows = '';
        trashBin.slice(2).forEach((item, i) => {
            hiddenRows += createTrashRow(item, i + 2);
        });

        t.innerHTML += `
        <details style="margin-top:5px; border-top:1px solid var(--btn);">
            <summary style="padding:10px; font-size:12px; color:var(--accent); cursor:pointer; text-align:center; font-weight:bold; list-style:none;">
                üîΩ Alle anzeigen (${trashBin.length})
            </summary>
            <div style="background:rgba(0,0,0,0.02); border-radius:8px;">
                ${hiddenRows}
            </div>
        </details>
        `;
    }
}

// HELPER: Autocomplete f√ºr Orte
/* === INTELLIGENTE ORTS-SUCHE (Lokal + Web) === */
function setupLocationAutocomplete() {
    const inp = getEl('noteLoc');
    const res = getEl('noteLocResults');
    let osmTimer; // Timer f√ºr die Internet-Suche

    inp.oninput = (e) => {
        const val = e.target.value.trim();
        
        // Reset
        res.innerHTML = '';
        if(val.length < 2) { res.style.display='none'; return; }
        
        res.style.display = 'block';

        // 1. LOKALE SUCHE (Sofort)
        // Wir filtern deine gespeicherten Orte
        const localMatches = locations.filter(l => l.toLowerCase().includes(val.toLowerCase()));

        // Funktion zum Erstellen einer Zeile
        const addRow = (text, type) => {
            const div = document.createElement('div');
            div.className = 'suggestion-item';
            
            // Icon Logik: üìç f√ºr Eigene, üåç f√ºr Web
            const icon = type === 'local' ? 'üìç' : 'üåç';
            const label = type === 'local' 
                ? `<b>${text}</b> <span style="font-size:10px; opacity:0.6">(Gespeichert)</span>`
                : `${text}`;

            div.innerHTML = `${icon} ${label}`;
            
            div.onclick = () => {
                inp.value = text;
                res.style.display = 'none';
            };
            res.appendChild(div);
        };

        // Lokale Ergebnisse sofort anzeigen
        localMatches.forEach(l => addRow(l, 'local'));

        // 2. WEB SUCHE (Verz√∂gert, um Daten zu sparen)
        clearTimeout(osmTimer);
        osmTimer = setTimeout(() => {
            // Nur suchen, wenn wir online sind
            if(!navigator.onLine) return;

            // Anfrage an OpenStreetMap (Nominatim)
            // limit=3 sorgt daf√ºr, dass die Liste nicht explodiert
            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}&addressdetails=1&limit=3&accept-language=de`)
            .then(r => r.json())
            .then(data => {
                // Wir filtern Duplikate heraus (falls der Ort schon lokal existiert)
                const newOsmMatches = data.filter(item => {
                    const cleanName = item.display_name.split(',')[0]; 
                    return !locations.includes(cleanName) && !locations.includes(item.display_name);
                });

                if(newOsmMatches.length > 0) {
                    // Trennlinie, falls wir schon lokale Ergebnisse haben
                    if(localMatches.length > 0) {
                        const sep = document.createElement('div');
                        sep.style.cssText = "font-size:10px; font-weight:bold; opacity:0.5; padding:4px 12px; background:var(--bg); border-top:1px solid var(--btn); text-transform:uppercase;";
                        sep.innerText = "Aus dem Web:";
                        res.appendChild(sep);
                    }

                    newOsmMatches.forEach(item => {
                        // Wir nehmen nur den vorderen Teil des Namens (z.B. "Berlin" statt "Berlin, Deutschland...")
                        // Das sieht sauberer aus.
                        const shortName = item.display_name.split(',')[0];
                        addRow(shortName, 'web');
                    });
                }
            })
            .catch(err => console.log("OSM Suche fehlgeschlagen", err));
        }, 400); // 400ms warten nach dem Tippen
    };
    
    // Schlie√üen beim Klick woanders hin
    document.addEventListener('click', (e) => {
        if(e.target !== inp) res.style.display='none';
    });
}

// Hilfsfunktion f√ºr Long-Press
function addLongPress(el, onClick, onLong) {
    let timer;
    const delay = 600; // 0.6 Sekunden dr√ºcken
    let isLong = false;

    const start = (e) => {
        isLong = false;
        timer = setTimeout(() => { isLong = true; onLong(e); }, delay);
    };
    const end = (e) => {
        clearTimeout(timer);
        if (!isLong) onClick(e); // Nur klicken, wenn nicht lange gedr√ºckt wurde
        e.preventDefault(); // Verhindert Ghost-Clicks
    };

    el.addEventListener('touchstart', start, {passive:false});
    el.addEventListener('touchend', end, {passive:false});
    el.addEventListener('mousedown', start);
    el.addEventListener('mouseup', end);
}

// === NOTES ===
let editNoteRef = null;

function openNoteModal(i, date=null, arrIdx=null){
    // Reset Quick Mode (UI aufr√§umen)
    if(typeof isQuickSightingMode !== 'undefined') isQuickSightingMode = false;
    
    // UI auf Normalzustand f√ºr "Einzelnes Tier" setzen
    const titleEl = getEl('noteModalTitle');
   
if(titleEl) { titleEl.innerHTML = ` <span style="display:inline-flex; align-items:center; justify-content:center; background:var(--accent); color:white; border-radius:10px; width:34px; height:34px; font-size:22px; font-weight:900; vertical-align:middle; margin-right:10px; box-shadow:0 4px 10px var(--accent-glow); padding-bottom:2px;">+</span> Sichtung `; }  const wrapper = getEl('noteAnimalWrapper');
    if(wrapper) wrapper.style.display = 'none'; // Tier-Suchfeld VERSTECKEN

    const modal = getEl('noteModal');
    
    // Autocomplete f√ºr Orte aktivieren
    if(typeof setupLocationAutocomplete === 'function') setupLocationAutocomplete();
    
    // Bestehende Notiz bearbeiten?
    if(date && arrIdx !== null) {
        editNoteRef = { date, i, arrIdx };
        const h = getHistory(parseInt(date.split('-')[0]));
        // Safety check falls history leer
        if(h && h[date] && h[date].perAnimal && h[date].perAnimal[i]) {
            const entry = h[date].perAnimal[i][arrIdx];
            getEl('noteDate').value = date; 
            getEl('noteTime').value = entry.time||''; 
            getEl('noteLoc').value = entry.location||''; // Value statt HTML
            getEl('noteText').value = entry.note||'';
        }
    } else {
        // Neue Notiz f√ºr bestehendes Tier
        editNoteRef = null;
        getEl('noteDate').value = todayStr(); 
        getEl('noteTime').value = nowTimeStr();
        getEl('noteLoc').value = ''; 
        getEl('noteText').value = '';
    }
    
    // Speicher Button Logik
    getEl('noteSaveBtn').onclick = () => {
        const d = getEl('noteDate').value || todayStr();
        
        // Ort Logik: Wenn neu, dann zur globalen Liste hinzuf√ºgen
        const rawLoc = getEl('noteLoc').value.trim();
        if(rawLoc && !locations.includes(rawLoc)) {
            locations.push(rawLoc);
            saveGlobals();
            if(typeof renderLocations === 'function') renderLocations();
            showErrorToast(`Neuer Ort "${rawLoc}" gespeichert!`, true);
        }

        const data = { 
            time: getEl('noteTime').value, 
            location: rawLoc, 
            note: getEl('noteText').value 
        };
        
        // Wenn wir editieren -> alten Eintrag l√∂schen
        if(editNoteRef) removeEntry(editNoteRef.date, editNoteRef.i, editNoteRef.arrIdx);
        else playSound('pop');
        
        // Speichern
        writeEntry(d, i, data);
        
        // 1. Modal schlie√üen (nur das obere!)
        closeModal('noteModal');
        
        // 2. CHECK: Ist Detailansicht im Hintergrund offen? Dann Refreshen!
        if(getEl('detailModal').style.display === 'block') {
            updateDetailChart(); // L√§dt die Statistik/Liste im Detailfenster neu
        }
        
        // 3. Hauptliste im Hintergrund aktualisieren
        render();
    };
    
    modal.style.display='block';
}

/* === VIEW NOTE DETAIL (Lese-Modus) === */
function viewNoteDetail(animalIdx, dateStr, arrIdx) {
    const h = getHistory(parseInt(dateStr.split('-')[0]));
    
    // Daten holen
    if (h && h[dateStr] && h[dateStr].perAnimal && h[dateStr].perAnimal[animalIdx]) {
        const entry = h[dateStr].perAnimal[animalIdx][arrIdx];
        
        // Modal f√ºllen
        const displayDate = dateStr.split('-').reverse().join('.');
        getEl('nvDate').innerText = displayDate;
        getEl('nvLoc').innerText = entry.location ? `üìç ${entry.location}` : '';
        getEl('nvText').innerText = entry.note || "Keine Notiz.";
        
        // Edit Button scharf schalten
        // Dieser Knopf √∂ffnet dann das "alte" Bearbeiten-Fenster und schlie√üt das Lese-Fenster
        getEl('nvEditBtn').onclick = function() {
            closeModal('noteViewModal');
            setTimeout(() => {
                openNoteModal(animalIdx, dateStr, arrIdx);
            }, 200);
        };
        
        // Anzeigen
        getEl('noteViewModal').style.display = 'block';
    }
}

// === EDIT ANIMAL (NAME, ICON, TAGS, IMAGE) ===
let editIconIdx = null; 
let editIconTemp = null;

async function openIconEdit(i){
    editIconIdx = i; 
    editIconTemp = null;
    const a = animals[i];
    
    // Werte laden
    getEl('editName').value = a.name; // NEU: Name laden
    getEl('editEmoji').value = a.emoji;
    getEl('editTag').value = (a.tags||[]).join(', ');
    
    // Bild Vorschau laden
    const prev = getEl('editPreviewImg');
    const container = getEl('editPreviewContainer');
    
    if(a.imageId) {
        const src = await dbGetImg(a.imageId);
        if(src) {
            prev.src = src;
            container.style.display = 'block';
        } else {
            container.style.display = 'none';
        }
    } else { 
        container.style.display = 'none'; 
    }
    
    getEl('iconModal').style.display='block';
}



function handleEditFile(input){
    if(input.files[0]) {
        const reader = new FileReader();
        reader.onload = e => resizeImage(e.target.result, 800, res => { editIconTemp = res; getEl('editPreviewImg').src = res; getEl('editPreviewContainer').style.display='block'; });
        reader.readAsDataURL(input.files[0]);
    }
}
async function removeEditImage(){ editIconTemp = 'DELETE'; getEl('editPreviewContainer').style.display='none'; }


async function saveIconEdit(){
    if(editIconIdx === null) return;
    const a = animals[editIconIdx];
    
    // 1. Name speichern
    const newName = getEl('editName').value.trim();
    if(newName) a.name = newName;
    
    // 2. Rest speichern
    a.emoji = getEl('editEmoji').value || 'üêæ';
    a.tags = getEl('editTag').value.split(',').map(s=>s.trim()).filter(s=>s);
    
    // 3. Bild Logik
    if(editIconTemp === 'DELETE') { 
        if(a.imageId) await dbDelImg(a.imageId); 
        a.imageId = null; 
    }
    else if(editIconTemp) { 
        if(a.imageId) await dbDelImg(a.imageId); 
        const newId = 'img_' + Date.now(); 
        await dbSaveImg(newId, editIconTemp); 
        a.imageId = newId; 
    }
    
    saveGlobals(); 
    render(); 
    updateStorageUI(); 
    
    // 1. Modal schlie√üen (nur das Bearbeiten-Fenster)
    closeModal('iconModal');
    
    // 2. CHECK: Ist Detailansicht offen? Dann KOMPLETT neu laden (f√ºr neuen Namen/Bild)
    if(getEl('detailModal').style.display === 'block') {
        openDetail(editIconIdx); // Ruft die Funktion neu auf -> Header & Bild aktualisieren sich
    }
    
    showErrorToast("√Ñnderungen gespeichert", true);
}

function quickCreate(name) {
    if(!name) return;
    
    // Tier anlegen (Kategorie leer lassen -> User sieht das sp√§ter)
    animals.push({ 
        name: name, 
        emoji: 'üêæ', 
        imageId: null, 
        tags: [], // Noch keine Tags
        isFav: false 
    });
    
    saveGlobals();
    getEl('listSearch').value = ''; // Suche leeren
    
    showErrorToast(`"${name}" angelegt!`, true);
    
    // Wir rendern neu
    render();
    
    // OPTIONAL: Wir √∂ffnen direkt das Bearbeiten Fenster, 
    // falls du es SOFORT kategorisieren willst.
    // Wenn du das NICHT willst (wegen Schnelligkeit), kommentiere die n√§chste Zeile aus:
    // openIconEdit(animals.length - 1); 
}

// === EXPORT / IMPORT ===
async function downloadBackup(){
    const fullHistory = {}; getAvailableYears().forEach(y => fullHistory[y] = getHistory(y));
    const images = {};
    if(animals.length) {
        showErrorToast("Backup wird erstellt... das kann kurz dauern.", true);
        for(let a of animals) { if(a.imageId) { const data = await dbGetImg(a.imageId); if(data) images[a.imageId] = data; } }
    }
    const exportObj = { meta:{v:"6.3", date:new Date()}, animals, locations, locCoords, fullHistory, images, notifyConfig };
    const blob = new Blob([JSON.stringify(exportObj)], {type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `tiere-backup-${todayStr()}.json`; a.click();
    //Nach dem Download:
 localStorage.setItem('lastBackup', Date.now()); 
// Sofort pr√ºfen -> Das entfernt den Punkt und die Box sofort!
 checkBackupHealth(); showErrorToast("Backup erstellt! Super üëç", true); // Positives Feedback
}
function importBackup(e){
    const file = e.target.files[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = evt => { try { tempImportData = JSON.parse(evt.target.result); getEl('importModal').style.display='block'; } catch(err) { showErrorToast("Datei besch√§digt"); } };
    reader.readAsText(file);
}
async function confirmImport(mode){
    getEl('importModal').style.display='none'; if(mode==='cancel') return;
    try {
        const d = tempImportData;
        
        // 1. Bilder bereinigen (nur bei Overwrite)
        if(mode==='overwrite') {
            const allKeys = await new Promise(async r => { const db = await dbPromise; const req = db.transaction(STORE_IMGS).objectStore(STORE_IMGS).getAllKeys(); req.onsuccess = () => r(req.result); });
            for(let k of allKeys) await dbDelImg(k); 
            localStorage.clear();
        }
        
        // 2. Neue Bilder speichern
        if(d.images) for(let [id, data] of Object.entries(d.images)) await dbSaveImg(id, data);
        
        // 3. Daten einspielen
        if(mode==='overwrite') {
            animals = d.animals || []; 
            locations = d.locations || []; 
            locCoords = d.locCoords || {}; 
            notifyConfig = d.notifyConfig || notifyConfig;
            
            // WICHTIG: Papierkorb leeren, damit keine fehlerhaften Reste bleiben!
            trashBin = []; 

            if(d.fullHistory) Object.entries(d.fullHistory).forEach(([y, h]) => saveHistory(y, h));
            else if(d.history) saveHistory(currentSystemYear, d.history);
        } else {
            // MERGE (Zusammenf√ºgen) - Papierkorb bleibt wie er ist
            d.animals?.forEach(impA => { if(!animals.some(a => a.name === impA.name)) animals.push(impA); });
            
            // Locations mergen
            if(d.locations) d.locations.forEach(l => { if(!locations.includes(l)) locations.push(l); });

            let entriesToProcess = [];
            if(d.fullHistory) {
                Object.values(d.fullHistory).forEach(yearData => {
                    Object.entries(yearData).forEach(([dateStr, dayContent]) => {
                        if(dayContent.perAnimal) Object.entries(dayContent.perAnimal).forEach(([idxStr, list]) => {
                            let targetIdx = parseInt(idxStr);
                            if(d.animals && d.animals[idxStr]) { const impName = d.animals[idxStr].name; const localIdx = animals.findIndex(a => a.name === impName); if(localIdx !== -1) targetIdx = localIdx; }
                            list.forEach(item => entriesToProcess.push({ date: dateStr, idx: targetIdx, data: item }));
                        });
                    });
                });
            }
            entriesToProcess.forEach(e => { const y = e.date.split('-')[0]; const h = getHistory(y); let exists = false; if(h[e.date]?.perAnimal?.[e.idx]) exists = h[e.date].perAnimal[e.idx].some(ex => ex.time === e.data.time && ex.location === e.data.location); if(!exists) writeEntry(e.date, e.idx, e.data); });
        }
        
        saveGlobals(); 
        render(); 
        updateStorageUI(); 
        updateTrashUI(); // UI aktualisieren, damit Papierkorb-Bubble verschwindet (weil leer)
        showErrorToast("Import fertig!", true); 
        setTimeout(()=>location.reload(), 1500);

    } catch(e) { console.error(e); showErrorToast("Import Fehler: " + e.message); }
}

function exportCSV() {
    let csv = "Datum;Uhrzeit;Tier;Ort;Notiz\n";
    getAvailableYears().forEach(y => {
        const h = getHistory(y);
        Object.entries(h).forEach(([d, val]) => {
             if(val.perAnimal) Object.entries(val.perAnimal).forEach(([idx, list]) => {
                 const name = animals[idx]?.name || 'Unknown';
                 list.forEach(item => csv += `${d};${item.time};"${name}";"${item.location||''}";"${item.note||''}"\n`);
             });
        });
    });
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'tiere-export.csv'; a.click();
}

// === MAP & STATS ===
function initMap() {
    if(mapInstance) { mapInstance.invalidateSize(); return; }
    let center = [51.165, 10.451];
    if(Object.keys(locCoords).length) { const k=Object.keys(locCoords)[0]; center=[locCoords[k].lat, locCoords[k].lon]; }
    mapInstance = L.map('map').setView(center, 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution:'&copy; OSM'}).addTo(mapInstance);
    
    const locCounts = {};
    getAvailableYears().forEach(y => {
        const h = getHistory(y);
        Object.values(h).forEach(d => { if(d.perAnimal) Object.values(d.perAnimal).forEach(list => list.forEach(item => { if(item.location && locCoords[item.location]) locCounts[item.location] = (locCounts[item.location]||0)+1; })); });
    });
  
/* IN initMap() - Neuer Marker Code */
    Object.entries(locCounts).forEach(([name, count]) => {
        const c = locCoords[name];
        
        // Custom Pin Icon
        const customIcon = L.divIcon({
            className: 'custom-map-pin',
            html: `<div style="background-color:var(--accent); color:white; border:2px solid white; border-radius:50%; width:30px; height:30px; display:flex; align-items:center; justify-content:center; font-weight:bold; font-size:14px; box-shadow:0 4px 8px rgba(0,0,0,0.3);">${count}</div>`,
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });

        const marker = L.marker([c.lat, c.lon], {icon: customIcon}).addTo(mapInstance);
        
        // HIER DIE √ÑNDERUNG: Statt Popup -> Bottom Sheet √∂ffnen
        marker.on('click', (e) => {
            L.DomEvent.stopPropagation(e); // Verhindert Klick auf Karte
            openMapSheet(name, count);
        });
    });

    // Klick auf leere Karte schlie√üt das Sheet
    mapInstance.on('click', () => {
        getEl('mapSheet').classList.remove('active');
    });
} // Ende initMap

function renderStats(){
    const ct = getEl('statsContent'); 
    const ys = getAvailableYears(); 
    const sel = getEl('statsYearSelect');
    
    // Dropdown f√ºllen falls leer
    if(sel.options.length !== ys.length) {
        sel.innerHTML = ys.map(y => `<option value="${y}" ${y===currentSystemYear?'selected':''}>${y}</option>`).join('');
    }
    
    const sYr = parseInt(sel.value) || currentSystemYear;
    
    // 1. GLOBALE STATS (F√ºr Level & XP - √ºber ALLE Jahre)
    let gTot=0, gNote=0, gLoc=new Set(), streak=0;
    ys.forEach(y => {
        const h = getHistory(y); 
        Object.values(h).forEach(e => {
            gTot += (e.total||0); 
            if(e.perAnimal) Object.values(e.perAnimal).forEach(l => l.forEach(x => {
                if(x.note) gNote++;
                if(x.location) gLoc.add(x.location);
            }));
        });
    });
    
    // 2. JAHRES STATS (F√ºr das gew√§hlte Jahr sYr)
    const th = getHistory(sYr);
    let yTot = 0, yWk = 0, yDistinct = new Set();
    let time = { Morgens:0, Mittags:0, Abends:0, Nachts:0 };
    let mCounts = new Array(12).fill(0);
    let animalCounts = {}; // { animalIndex: count }

    Object.entries(th).forEach(([dStr, e]) => {
        yTot += e.total; 
        mCounts[new Date(dStr).getMonth()] += e.total; 
        if([0,6].includes(new Date(dStr).getDay())) yWk += e.total;
        
        if(e.perAnimal) {
            Object.entries(e.perAnimal).forEach(([k, l]) => { 
                const idx = parseInt(k);
                const aName = animals[idx]?.name || '???';
                yDistinct.add(aName); 
                
                // F√ºr Top 3 z√§hlen
                animalCounts[idx] = (animalCounts[idx] || 0) + l.length;

                l.forEach(x => {
                    if(x.time){
                        const h = parseInt(x.time); 
                        if(h>=5 && h<11) time.Morgens++;
                        else if(h>=11 && h<14) time.Mittags++;
                        else if(h>=14 && h<22) time.Abends++;
                        else time.Nachts++;
                    }
                }); 
            });
        }
    });

    // 3. LEVEL BERECHNUNG & DESIGN
    const photo = animals.some(a => a.imageId);
    // Streak Berechnung
    const dates = Object.keys(th).sort((a,b) => new Date(b)-new Date(a));
    if(dates.length){ 
        const dh = (new Date(todayStr())-new Date(dates[0]))/36e5; 
        if(dh <= 48){
            streak = 1;
            for(let i=0; i<dates.length-1; i++) {
                if(Math.round((new Date(dates[i])-new Date(dates[i+1]))/864e5)===1) streak++; else break;
            }
        }
    }

    const xp = (gTot*40) + (gNote*75) + (animals.length*50) + (photo?100:0) + (gLoc.size*25) + (streak*100);
    
    // Level Logik
    let lvl = levels[0], nxt = null; 
    let lvlIdx = 0;
    for(let i=0; i<levels.length; i++){ 
        if(xp >= levels[i].xp){ lvl = levels[i]; lvlIdx = i; } 
        else { nxt = levels[i]; break; }
    }
    const pct = nxt ? Math.min(((xp-lvl.xp)/(nxt.xp-lvl.xp))*100,100) : 100;

   // --- DESIGN & ICON W√ÑHLEN (5 ZONEN) ---
    let rankClass = 'rank-garden'; // Default
    let rankIcon = 'üêû'; 

    // Zone 1: Garten (Level 1-4)
    if (lvlIdx < 4) {
        rankClass = 'rank-garden';
        if(lvlIdx >= 2) rankIcon = 'ü¶î'; // Igel ab Lvl 3
    }
    // Zone 2: Wald (Level 5-8)
    else if (lvlIdx >= 4 && lvlIdx < 8) {
        rankClass = 'rank-forest';
        rankIcon = 'üå≤'; 
        if(lvlIdx >= 6) rankIcon = 'ü¶â'; // Eule ab Lvl 7
    }
    // Zone 3: Wasser (Level 9-12)
    else if (lvlIdx >= 8 && lvlIdx < 12) {
        rankClass = 'rank-water';
        rankIcon = 'üê∏';
        if(lvlIdx >= 10) rankIcon = 'üê¨'; // Delfin ab Lvl 11
    }
    // Zone 4: Savanne (Level 13-16)
    else if (lvlIdx >= 12 && lvlIdx < 16) {
        rankClass = 'rank-savanna';
        rankIcon = 'üêí';
        if(lvlIdx >= 14) rankIcon = 'ü¶Å'; // L√∂we ab Lvl 15
    }
    // Zone 5: Legende (Level 17-20)
    else {
        rankClass = 'rank-legend';
        rankIcon = 'ü¶Ö';
        if(lvlIdx >= 18) rankIcon = 'üê∫'; // Wolf ab Lvl 19
        if(lvlIdx === 19) rankIcon = 'üëë'; // Krone f√ºr Max Level
    }

    // --- HTML ZUSAMMENBAUEN ---
    
// === NEU: DASHBOARD BUTTON JETZT HIER (Zwischen KPI und Top 3) ===
    
    // Heutigen Count berechnen
    const todayKeyForStats = new Date().toISOString().slice(0,10);
    const todayCountStats = getHistory(currentSystemYear)[todayKeyForStats]?.total || 0;

    let html = `
    <div class="dashboard-hero-stats" onclick="safeRun(openTodayModal)">
      <div>
        <h2 style="margin:0; font-size: 28px; font-weight: 900;" id="heroCountStats">${todayCountStats}</h2>
        <p style="margin:0; opacity: 0.9; font-size: 13px; font-weight:bold;">Tiere heute entdeckt</p>
      </div>
      <div style="font-size: 24px; background:rgba(255,255,255,0.2); width:40px; height:40px; border-radius:50%; display:flex; align-items:center; justify-content:center;">‚ûî</div>
    </div>`;
    // === ENDE NEUER BUTTON ===



    // 1. Die neue Level Karte

html += ` 
  <div class="level-card fade-in ${rankClass}">
        <div class="lvl-header">
            <span>Level ${lvlIdx + 1}</span>
            <span>${xp} XP</span>
        </div>
        <div class="lvl-icon-big">${rankIcon}</div>
        <div class="lvl-name">${lvl.name}</div>
        <div class="lvl-progress-container">
            <div class="lvl-bar-bg">
                <div class="lvl-bar-fill" style="width:${pct}%"></div>
            </div>
            <div class="lvl-stats-text">
                <span>Aktuell</span>
                <span>${nxt ? (nxt.xp - xp) + ' bis Aufstieg' : 'MAX LEVEL'}</span>
            </div>
        </div>
    </div>`;
    
// ... (Dein Code davor bleibt gleich) ...

 // === 2. LEVEL ROADMAP (Timeline Style) ===
    // Wir bauen die Zeilen dynamisch als Bubbles
    const roadmapItems = levels.map((l, i) => {
        let zoneClass = 'rm-garden';
        let zoneIcon = 'üêû'; 

        // Zonen-Logik
        if (i < 4) { zoneClass = 'rm-garden'; zoneIcon = 'üêû'; }
        else if (i < 8) { zoneClass = 'rm-forest'; zoneIcon = 'üå≤'; }
        else if (i < 12) { zoneClass = 'rm-water'; zoneIcon = 'üê¨'; }
        else if (i < 16) { zoneClass = 'rm-savanna'; zoneIcon = 'ü¶Å'; }
        else { zoneClass = 'rm-legend'; zoneIcon = 'üëë'; }

        // Aktuelles Level markieren
        const isCurrent = (i === lvlIdx);
        const activeClass = isCurrent ? 'active' : '';
        const displayIcon = isCurrent ? 'üìç' : zoneIcon; 
        const opacity = i > lvlIdx ? '0.5' : '1'; // Zuk√ºnftige Levels leicht ausblenden

        return `
        <div class="roadmap-item ${zoneClass} ${activeClass}" style="opacity:${opacity}">
            <div class="roadmap-dot"></div>
            <div style="font-size:20px;">${displayIcon}</div>
            <div style="display:flex; flex-direction:column;">
                <span style="font-weight:bold; font-size:13px;">${l.name}</span>
                <span style="font-size:10px; opacity:0.7;">Level ${i+1}</span>
            </div>
            <div class="roadmap-xp">${l.xp.toLocaleString()} XP</div>
        </div>`;
    }).join('');

    // Akkordeon Container f√ºr die Roadmap
    html += `
    <details style="margin-bottom:25px; border:1px solid rgba(0,0,0,0.05); border-radius:24px; padding:15px; background:var(--card); box-shadow:var(--shadow);">
        <summary style="font-weight:800; color:var(--text); cursor:pointer; list-style:none; display:flex; align-items:center; gap:10px;">
            <span style="font-size:20px;">üó∫Ô∏è</span> Deine Reise-Route <span style="opacity:0.5; font-weight:normal; font-size:12px; margin-left:auto;">(Alle Level) ‚ñº</span>
        </summary>
        <div class="roadmap-container">
            <div class="roadmap-line"></div>
            ${roadmapItems}
        </div>
    </details>`;

    if(gTot === 0) { ct.innerHTML = html+'<div style="text-align:center">Noch keine Daten.</div>'; return; }

    // === 3. NEUE KPI BUBBLES (Grid) ===
    html += `
    <div class="kpi-grid">
        <!-- Sichtungen (Blau) -->
        <div class="kpi-bubble kpi-blue">
            <div class="kpi-icon">üëÅÔ∏è</div>
            <!-- HIER GE√ÑNDERT: ID hinzugef√ºgt und Startwert 0 -->
            <div class="kpi-val" id="kpi-stat-total">0</div>
            <div class="kpi-label">Sichtungen</div>
        </div>
        
        <!-- Arten (Gr√ºn) -->
        <div class="kpi-bubble kpi-green">
            <div class="kpi-icon">üß¨</div>
            <!-- HIER GE√ÑNDERT: ID hinzugef√ºgt und Startwert 0 -->
            <div class="kpi-val" id="kpi-stat-species">0</div>
            <div class="kpi-label">Arten</div>
        </div>
        
        <!-- Streak (Orange) -->
        <div class="kpi-bubble kpi-orange">
            <div class="kpi-icon">üî•</div>
            <!-- HIER GE√ÑNDERT: ID hinzugef√ºgt und Startwert 0 -->
            <div class="kpi-val" id="kpi-stat-streak">0</div>
            <div class="kpi-label">Tage Streak</div>
        </div>
        
        <!-- Aktivste Zeit (Lila) - Bleibt Text, daher kein Tacho -->
        <div class="kpi-bubble kpi-purple">
            <div class="kpi-icon">‚åö</div>
            <div class="kpi-val" style="font-size:18px; margin-top:4px;">
                ${Object.entries(time).sort((a,b)=>b[1]-a[1])[0]?.[0] || '-'}
            </div>
            <div class="kpi-label">Top Zeit</div>
        </div>
    </div>`;


    // 4. TOP 3 (Deine Logik, beibehalten)
    const sortedTop = Object.entries(animalCounts)
        .map(([idx, count]) => ({ idx: parseInt(idx), count }))
        .sort((a,b) => b.count - a.count)
        .slice(0, 3); 

    if(sortedTop.length > 0) {
        const medals = ['ü•á', 'ü•à', 'ü•â'];
        const maxVal = sortedTop[0].count; 
        html += `<div class="card-section"><h3>üèÜ Top 3 Lieblinge (${sYr})</h3><div class="top3-container">`;
        sortedTop.forEach((item, rank) => {
            const a = animals[item.idx];
            if(!a) return;
            const percent = (item.count / maxVal) * 100;
            const imgId = `stat-top3-${item.idx}-${sYr}`;
            html += `<div class="top3-row"><div class="top3-bar" style="width:${percent}%"></div><div class="top3-medal">${medals[rank]}</div><div class="top3-img" id="${imgId}">${a.emoji}</div><div class="top3-info"><span>${a.name}</span><span class="top3-count">${item.count}</span></div></div>`;
            if(a.imageId) { dbGetImg(a.imageId).then(src => { const el = document.getElementById(imgId); if(src && el) { el.innerHTML = `<img src="${src}">`; el.style.border = "none"; } }); }
        });
        html += `</div></div>`;
    }

    // 5. TROPH√ÑEN
    const badges=[
          {i:'üê£',n:'Starter',c:gTot>=1},{i:'ü•â',n:'Sammler',c:gTot>=50},{i:'ü•à',n:'Profi',c:gTot>=100},{i:'üëë',n:'Legende',c:gTot>=250},{i:'ü™ê',n:'Titan',c:gTot>=1000},
          {i:'üî•',n:'On Fire',c:streak>=3},{i:'‚ö°',n:'Marathon',c:streak>=7},{i:'üìÖ',n:'Weekend',c:yWk>0},{i:'üç±',n:'Mittag',c:time.Mittags>0},
          {i:'üåà',n:'Arche',c:yDistinct.size>=10},{i:'üß¨',n:'Darwin',c:yDistinct.size>=25},{i:'üåç',n:'Entdecker',c:gLoc.size>=3},
          {i:'üó∫Ô∏è',n:'Globe',c:gLoc.size>=10},{i:'üì∏',n:'Paparazzi',c:photo},{i:'ü¶â',n:'Nachteule',c:time.Nachts>0},{i:'üêì',n:'Fr√ºh',c:time.Morgens>0}
    ];
    html += `<div class="card-section"><h3>üèÜ Troph√§en</h3><div class="badge-grid">`+badges.map(b=>`<div class="badge ${b.c?'earned':''}"><span class="badge-icon">${b.i}</span> ${b.n}</div>`).join('')+`</div></div>`;
    
    // 6. TAGESZEITEN
    const maxT = Math.max(...Object.values(time), 1);
    html += `<div class="card-section"><h3>‚è±Ô∏è Tageszeiten</h3>`+Object.entries(time).map(([l,v])=>`<div class="hbar-row"><div class="hbar-label" style="width:80px">${l}</div><div class="hbar-track"><div class="hbar-fill" style="width:${(v/maxT)*100}%;opacity:0.8"></div></div><div class="hbar-val">${v}</div></div>`).join('')+`</div>`;
    
    // 7. JAHRES CHART
    html += `<div class="card-section"><h3>üóìÔ∏è Jahr ${sYr}</h3><div class="chart-wrap">`+mCounts.map((v,i)=>`<div class="chart-col"><div class="chart-bar" style="height:${v?(v/Math.max(...mCounts))*100:1}%;opacity:${v?1:0.1}"></div><div class="chart-label">${['J','F','M','A','M','J','J','A','S','O','N','D'][i]}</div></div>`).join('')+`</div></div>`;
    
  
// === 8. HEATMAP (Kalender-orientiert) ===
    
    // 1. FEHLENDE DEFINITION WIEDER EINGEF√úGT:
    // Wenn aktuelles Jahr gew√§hlt: Heute. Wenn vergangenes Jahr: 31. Dezember.
    let refDate = (sYr === currentSystemYear) ? new Date() : new Date(sYr, 11, 31);
    
    const today = new Date(refDate);
    const dayOfWeek = today.getDay(); // 0 (So) - 6 (Sa)
    
    // JS: Sonntag ist 0, wir wollen Montag als Start (0). 
    const daysSinceMonday = (dayOfWeek + 6) % 7;
    
    // Startdatum berechnen (Der Montag vor ca. 4 Wochen)
    const startDate = new Date(today);
    startDate.setDate(today.getDate() - (28 + daysSinceMonday));

    // HTML Header
    html += `
    <div class="card-section">
        <h3>üî• Aktivit√§t (30 Tage)</h3>
        <div class="heatmap-container">
            <!-- Wochentage Header -->
            <div class="heatmap-weekdays">
                <div class="heatmap-day-label">Mo</div>
                <div class="heatmap-day-label">Di</div>
                <div class="heatmap-day-label">Mi</div>
                <div class="heatmap-day-label">Do</div>
                <div class="heatmap-day-label">Fr</div>
                <div class="heatmap-day-label">Sa</div>
                <div class="heatmap-day-label">So</div>
            </div>
            
            <div class="heatmap-grid" id="heatmapGrid">`;

    // Zellen generieren (5 Wochen = 35 Zellen)
    for (let i = 0; i < 35; i++) { 
        const d = new Date(startDate);
        d.setDate(startDate.getDate() + i + 1); 
        
        const iso = d.toISOString().slice(0,10);
        const isFuture = d > today;
        
        if (isFuture) {
            // Leere Zellen f√ºr die Zukunft
            html += `<div class="heat-cell" style="background:transparent; cursor:default;"></div>`;
        } else {
            const count = getHistory(d.getFullYear())[iso]?.total || 0;
            const isToday = (iso === todayStr());
            
            // Farbe berechnen
            let bg = 'var(--btn)';
            if(count > 0) bg = `rgba(33, 150, 243, ${Math.min(count*0.25 + 0.2, 1)})`; 
            
            // Info Text vorbereiten
            const dayName = d.toLocaleDateString('de-DE', { weekday:'short', day:'2-digit', month:'2-digit' });
            
            html += `
            <div class="heat-cell ${isToday?'is-today':''}" 
                 style="background:${bg}; color:${count>0?'#ffffff':'transparent'}; text-shadow:0 1px 2px rgba(0,0,0,0.3); font-weight:bold;"
                 onclick="showHeatmapInfo(this, '${dayName}', ${count})">
                 ${count || ''}
            </div>`;
        }
    }

    html += `
            </div>
            <!-- Hier erscheint der Text beim Klicken -->
            <div id="heatmapInfoText" class="heatmap-info-line">Tippe auf einen Tag üëÜ</div>
        </div>
    </div>`;
    
    ct.innerHTML = html;
    
    // === ANIMATION STARTEN (TACHO EFFEKT) ===
    // Wir warten 50ms, damit der Browser das HTML erst mal "malen" kann
    setTimeout(() => {
        // Pr√ºfen ob die animateValue Funktion existiert (die haben wir vorhin angelegt)
        if(typeof animateValue === 'function') {
            // Von 0 auf den Zielwert in 1500ms
            animateValue(document.getElementById('kpi-stat-total'), 0, yTot, 1500);
            animateValue(document.getElementById('kpi-stat-species'), 0, yDistinct.size, 1500);
            animateValue(document.getElementById('kpi-stat-streak'), 0, streak, 1500);
      if(document.getElementById('heroCountStats')) {
    animateValue(document.getElementById('heroCountStats'), 0, todayCountStats, 1000);
}

  } else {
            // Fallback, falls die Animation-Funktion fehlt: Werte direkt setzen
            if(document.getElementById('kpi-stat-total')) document.getElementById('kpi-stat-total').innerText = yTot;
            if(document.getElementById('kpi-stat-species')) document.getElementById('kpi-stat-species').innerText = yDistinct.size;
            if(document.getElementById('kpi-stat-streak')) document.getElementById('kpi-stat-streak').innerText = streak;
        }
    }, 50);

} // Ende der Funktion renderStats
    

/* === ULTIMATE SHARE CARD GENERATOR (V2) === */
async function generateShareCard() {
    showErrorToast("üé® Erstelle Grafik...", true); // Feedback geben

    // 1. SETUP & DATEN
    const width = 800;
    const height = 1200;
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    const year = parseInt(getEl('statsYearSelect').value) || currentSystemYear;
    const h = getHistory(year);
    
    // Daten berechnen (Gesamt & Top 1)
    let total = 0;
    let counts = {}; // { animalIndex: count }
    
    Object.entries(h).forEach(([date, d]) => {
        total += d.total || 0;
        if(d.perAnimal) {
            Object.entries(d.perAnimal).forEach(([idx, list]) => {
                counts[idx] = (counts[idx] || 0) + list.length;
            });
        }
    });

    // Top 1 finden
    let topAnimal = null;
    let topCount = 0;
    const sortedIdx = Object.keys(counts).sort((a,b) => counts[b] - counts[a]);
    if(sortedIdx.length > 0) {
        topAnimal = animals[parseInt(sortedIdx[0])];
        topCount = counts[sortedIdx[0]];
    }

    // Level berechnen (f√ºr den Header)
    // Wir nutzen hier eine vereinfachte XP Rechnung nur f√ºr die Karte, 
    // oder holen uns die XP global, falls verf√ºgbar.
    // Wir nehmen hier einfach den "Rang Titel" basierend auf der Total-Zahl (Quick Hack)
    // oder besser: Wir berechnen kurz die echten XP wie in renderStats.
    // (Hier gek√ºrzt auf Basis von Total f√ºr Geschwindigkeit):
    const titleText = `Mein Tierjahr ${year}`;

    // 2. HINTERGRUND (Modern Gradient)
    const grad = ctx.createLinearGradient(0, 0, width, height);
    grad.addColorStop(0, '#2b1055'); // Dunkel Lila
    grad.addColorStop(1, '#7597de'); // Hellblau
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);

    // Partikel im Hintergrund (Sterne/Glitzer)
    ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
    for(let i=0; i<40; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const r = Math.random() * 4;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    }

    // 3. GLAS-CARD (Container in der Mitte)
    const cardX = 50, cardY = 150, cardW = 700, cardH = 900;
    ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
    ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 30; ctx.shadowOffsetY = 20;
    
    // Rounded Rect Helper
    roundRect(ctx, 50, 100, 700, 1000, 40); 
    ctx.fill();
    ctx.shadowBlur = 0; ctx.shadowOffsetY = 0; // Reset Shadow

    // 4. TEXTE & INHALT
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffffff';

    // Header
    ctx.font = 'bold 40px sans-serif';
    ctx.fillText("TIER TICKER üêæ", width/2, 180);
    ctx.font = '30px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.fillText(titleText, width/2, 230);

    // TOTAL COUNT (Riesig)
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 180px sans-serif';
    ctx.shadowColor = "rgba(0,0,0,0.2)"; ctx.shadowBlur = 10;
    ctx.fillText(total, width/2, 450);
    ctx.shadowBlur = 0;
    
    ctx.font = '30px sans-serif';
    ctx.fillStyle = '#4cd137'; // Gr√ºn
    ctx.fillText("GESAMT SICHTUNGEN", width/2, 500);

    // TRENNLINIE
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(150, 560); ctx.lineTo(650, 560); ctx.stroke();

    // 5. TOP 1 TIER (MVP)
    if(topAnimal) {
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.font = 'bold 35px sans-serif';
        ctx.fillText("üèÜ MEIST ENTDECKT", width/2, 620);

        const imgY = 670;
        const imgSize = 220;
        
        // Versuchen Bild zu laden
        let imgDrawn = false;
        if(topAnimal.imageId) {
            try {
                const src = await dbGetImg(topAnimal.imageId);
                if(src) {
                    const img = new Image();
                    img.src = src;
                    await new Promise(r => img.onload = r);
                    
                    // Bild Rund ausschneiden
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(width/2, imgY + imgSize/2, imgSize/2, 0, Math.PI*2);
                    ctx.closePath();
                    ctx.clip();
                    
                    // Bild zeichnen & skalieren (Cover fit)
                    const scale = Math.max(imgSize/img.width, imgSize/img.height);
                    const x = (width/2) - (img.width/2) * scale;
                    const y = (imgY + imgSize/2) - (img.height/2) * scale;
                    ctx.drawImage(img, x, y, img.width*scale, img.height*scale);
                    
                    // Goldener Rand
                    ctx.beginPath();
                    ctx.arc(width/2, imgY + imgSize/2, imgSize/2, 0, Math.PI*2);
                    ctx.lineWidth = 10; ctx.strokeStyle = "#ffd700"; ctx.stroke();
                    
                    ctx.restore();
                    imgDrawn = true;
                }
            } catch(e) { console.log("Bildfehler", e); }
        }

        // Fallback Emoji (wenn kein Bild oder Fehler)
        if(!imgDrawn) {
            ctx.font = '150px serif';
            ctx.fillText(topAnimal.emoji, width/2, imgY + 160);
        }

        // Name & Count des Top Tiers
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 50px sans-serif';
        ctx.fillText(topAnimal.name, width/2, 960);
        
        ctx.fillStyle = '#ffd700'; // Gold
        ctx.font = 'bold 40px sans-serif';
        ctx.fillText(`${topCount} mal gesehen`, width/2, 1020);
    } else {
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '30px sans-serif';
        ctx.fillText("Noch keine Favoriten...", width/2, 800);
    }

    // FOOTER
    ctx.font = '20px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillText("Erstellt mit Tier Ticker App", width/2, 1150);

    // DOWNLOAD
    //const link = document.createElement('a');
   // link.download = `TierTicker-Share-${year}.png`;
   // link.href = canvas.toDataURL('image/png');
    //link.click();

// ... (Canvas Code wie gehabt) ...

    // STATT DOWNLOAD -> NATIVE SHARE
    canvas.toBlob(async (blob) => {
        const file = new File([blob], "tier-stats.png", { type: "image/png" });
        
        // Pr√ºfen, ob der Browser echtes Teilen unterst√ºtzt
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
            try {
                await navigator.share({
                    title: 'Mein Tier-Ticker Jahr',
                    text: `Ich habe dieses Jahr ${total} Tiere gesehen! üêæ #TierTicker`,
                    files: [file]
                });
                showErrorToast("Erfolgreich geteilt! üöÄ", true);
            } catch (err) {
                console.log("Teilen abgebrochen", err);
            }
        } else {
            // Fallback: Alter Download
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = "tier-stats.png";
            a.click();
            showErrorToast("Bild gespeichert (Teilen nicht verf√ºgbar)", true);
        }
    });
}


// Helper f√ºr runde Ecken im Canvas
function roundRect(ctx, x, y, w, h, r) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

// === NOTIFICATIONS & UTILS ===
function saveNotifySettings(){
    notifyConfig.enabled = getEl('notifyToggle').checked;
    notifyConfig.days = parseInt(getEl('notifyDays').value) || 7;
    localStorage.setItem('notifyConfig', JSON.stringify(notifyConfig));
    showErrorToast("Einstellungen gespeichert", true); closeModal('notifyModal');
}
function testNotification(){
    if (Notification.permission === "granted") new Notification("Tier Ticker", { body: "Test-Erinnerung: Zeit zu z√§hlen! üêæ" });
    else if (Notification.permission !== "denied") Notification.requestPermission().then(p => { if (p === "granted") new Notification("Test", { body: "Erinnerungen aktiviert." }); });
}
function downloadICS() {
    let ics = "BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//TierTracker//DE\nBEGIN:VEVENT\nSUMMARY:Tiere z√§hlen üêæ\nRRULE:FREQ=" + getEl('icsFreq').value + (getEl('icsFreq').value==='WEEKLY' ? ";BYDAY="+getEl('icsDay').value : "") + "\nDTSTART:" + todayStr().replace(/-/g,'') + "T" + getEl('icsTime').value.replace(':','') + "00\nDURATION:PT15M\nDESCRIPTION:Zeit deine Beobachtungen einzutragen!\nEND:VEVENT\nEND:VCALENDAR";
    const a = document.createElement('a'); a.href = 'data:text/calendar;charset=utf-8,' + encodeURIComponent(ics); a.download = 'tiere-erinnerung.ics'; a.click();
}

function toggleDarkMode(){ dark=!dark; localStorage.setItem('darkmode',dark); document.body.classList.toggle('dark', dark); }
function switchView(id, btn){
    document.querySelectorAll('.view-section').forEach(e=>e.classList.remove('active')); getEl(id).classList.add('active');
    document.querySelectorAll('.nav-item').forEach(e=>e.classList.remove('active')); if(btn) btn.classList.add('active');
    if(id==='view-map') setTimeout(initMap, 200); if(id==='view-stats') renderStats();
}
function toggleInfo(){ const b = getEl('infoBox'); b.style.display = b.style.display==='none'?'block':'none'; }

// === SETTINGS & TOGGLES ===

// √ñffnet das neue zentrale Einstellungs-Men√º
function openSettings(){ 
    const modal = getEl('notifyModal');
    
    // 1. Dark Mode Status setzen
    const darkBox = getEl('settingDarkToggle');
    if(darkBox) darkBox.checked = dark;

    // 2. Kompakt Modus Status setzen
    const compactBox = getEl('compactToggle');
    if(compactBox) compactBox.checked = isCompact;

    // 3. Mute Status setzen
    const muteBox = getEl('settingMuteToggle');
    if(muteBox) muteBox.checked = isMuted;

    // 4. Notification Settings laden
    getEl('notifyToggle').checked = notifyConfig.enabled;
    getEl('notifyDays').value = notifyConfig.days;

    modal.style.display='block'; 
}

// Neue Funktion f√ºr den Mute-Switch im Men√º
function toggleMuteState() {
    isMuted = !isMuted;
    localStorage.setItem('muted', isMuted);
    // Kein Button-Text Update mehr n√∂tig, da Switch
}

// Die bestehende toggleDarkMode Funktion bleibt, 
// sie wird jetzt vom Switch im Modal aufgerufen.
function closeModal(id){ getEl(id).style.display='none'; }
function hardReset(){ if(confirm("ALLES L√ñSCHEN?")) { localStorage.clear(); location.reload(); } }

// === GPS ===
function locateMe(){
    if(!navigator.geolocation) return showErrorToast("Kein GPS");
    showErrorToast("Suche Position...", true);
    navigator.geolocation.getCurrentPosition(p => {
        fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${p.coords.latitude}&lon=${p.coords.longitude}&zoom=18`)
        .then(r=>r.json()).then(d => {
            const name = (d.address.road || d.address.village || d.address.city || "Ort");
            getEl('osmInput').value = name; locCoords[name] = {lat:p.coords.latitude, lon:p.coords.longitude};
        }).catch(()=>showErrorToast("Ort nicht gefunden"));
    });
}

function addManualLocation(){ 
    const v = getEl('osmInput').value; 
    if(v && !locations.includes(v)) { 
        locations.push(v); 
        saveGlobals(); 
        
        renderLocations(); // <--- HIER GE√ÑNDERT (statt render())
        
        showErrorToast("Ort gespeichert", true); 
    } 
}

function deleteLocation(i) {
    if(confirm(`Ort "${locations[i]}" wirklich l√∂schen?`)) {
        locations.splice(i, 1);
        saveGlobals();
        
        renderLocations(); // <--- HIER GE√ÑNDERT (statt render())
        
        showErrorToast("Ort gel√∂scht", true);
    }
}

// === AUTOCOMPLETE LOGIC FROM FILE 2 ===
getEl('osmInput').addEventListener('keydown', (e) => { if(e.key === 'Enter') addManualLocation(); });
getEl('osmInput').addEventListener('input', e => { 
    if(e.target.value.length<3) { getEl('osmResults').style.display='none'; return; }
    clearTimeout(window.osmDebounce); 
    window.osmDebounce = setTimeout(() => { 
        fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${e.target.value}`)
        .then(r=>r.json()).then(d => { 
            const res = getEl('osmResults'); res.innerHTML='';
            if(d.length) {
                res.style.display='block';
                d.slice(0,3).forEach(x => { 
                    const div = document.createElement('div'); div.className='suggestion-item'; div.innerText=x.display_name.split(',')[0]; 
                    div.onclick=()=>{ getEl('osmInput').value=div.innerText; locCoords[div.innerText]={lat:parseFloat(x.lat),lon:parseFloat(x.lon)}; res.style.display='none'; addManualLocation(); }; 
                    res.appendChild(div); 
                });
            } else { res.style.display='none'; }
        }); 
    }, 500); 
});
document.addEventListener('click', (e) => { if(e.target !== getEl('osmInput')) getEl('osmResults').style.display='none'; });


// === LIGHTBOX LOGIC ===
function openImageLightbox(src) {
    const modal = document.getElementById('lightboxModal');
    const img = document.getElementById('lightboxImg');
    img.src = src;
    modal.style.display = 'flex';
    // Kleiner Timeout f√ºr Animationseffekt
    setTimeout(() => modal.classList.add('active'), 10);
}

function closeImageLightbox() {
    const modal = document.getElementById('lightboxModal');
    modal.classList.remove('active');
    setTimeout(() => modal.style.display = 'none', 200);
}


// --- UPDATE: Backup Health Check (Erweitert um Header Badge) ---
function checkBackupHealth() {
    const last = localStorage.getItem('lastBackup');
    const now = Date.now();
    const daysSince = last ? Math.floor((now - last) / (1000 * 60 * 60 * 24)) : 100;
    
    // Elemente holen
    const adminBtn = document.querySelectorAll('.nav-item')[1]; 
    const existingBadge = adminBtn ? adminBtn.querySelector('.warn-badge') : null;
    
    // Die Box innen
    const warnBox = getEl('backupWarningBox');
    const daysText = getEl('backupDaysCount');
    
    // Der Badge auf dem Header (wenn zugeklappt)
    const headerBadge = getEl('backupHeaderBadge');

    // Schwelle: Warnen ab 14 Tagen
    if (daysSince > 14) {
        // 1. Roter Punkt in der Navigation
        if (adminBtn && !existingBadge) {
            const badge = document.createElement('div');
            badge.className = 'warn-badge';
            badge.style.cssText = "position:absolute; top:5px; right:20px; width:10px; height:10px; background:var(--err-text); border-radius:50%; border:2px solid var(--card); z-index:10;";
            adminBtn.style.position = 'relative';
            adminBtn.appendChild(badge);
        }

        // 2. Warnbox innen (Text setzen)
        if(warnBox) {
            warnBox.style.display = 'flex';
            const timeText = last ? `vor ${daysSince} Tagen` : "noch nie";
            daysText.innerText = timeText;
        }
        
        // 3. NEU: Warnbadge auf dem Header anzeigen
        if(headerBadge) {
            headerBadge.style.display = 'block';
        }

    } else {
        // Alles gut: Aufr√§umen
        if (existingBadge) existingBadge.remove();
        if (warnBox) warnBox.style.display = 'none';
        if (headerBadge) headerBadge.style.display = 'none'; // Header Badge weg
    }
}

// Scroll Monitor
window.addEventListener('scroll', () => {
    const btn = getEl('scrollTopBtn');
    if(window.scrollY > 300) { // Erst ab 300px Scrolltiefe zeigen
        btn.style.display = 'flex';
        btn.style.opacity = '1';
    } else {
        btn.style.display = 'none';
    }
}, {passive: true});

// === NEW: OPEN TODAY MODAL ===
function openTodayModal() {
    const listCont = getEl('todayListContainer');
    listCont.innerHTML = ''; // Reset
    
    const h = getHistory(currentSystemYear);
    const todayKey = todayStr();
    const todayData = h[todayKey];

    if (!todayData || !todayData.perAnimal || todayData.total === 0) {
        listCont.innerHTML = '<div style="text-align:center; padding:40px; opacity:0.6">Noch keine Tiere heute.<br>Geh raus und such welche! üå≥</div>';
        getEl('todayModal').style.display = 'block';
        return;
    }

    // 1. Alle heutigen Eintr√§ge in eine flache Liste sammeln
    let timeline = [];
    Object.keys(todayData.perAnimal).forEach(idxStr => {
        const idx = parseInt(idxStr);
        const entries = todayData.perAnimal[idx];
        const animal = animals[idx];
        
        entries.forEach((entry, arrIdx) => {
            timeline.push({
                animalIdx: idx,
                name: animal.name,
                emoji: animal.emoji,
                time: entry.time || '00:00',
                location: entry.location || '',
                note: entry.note || '',
                arrIdx: arrIdx // F√ºr Editieren/L√∂schen wichtig
            });
        });
    });

    // 2. Sortieren nach Uhrzeit (Neueste oben)
    timeline.sort((a, b) => b.time.localeCompare(a.time));

    // 3. HTML generieren
    timeline.forEach((item, i) => {
        // Animation Delay f√ºr sch√∂nen Effekt
        const delay = i * 0.05;
        
        const row = document.createElement('div');
        row.className = 'today-row';
        row.style.animationDelay = delay + 's';
        
        // Falls keine Zeit eingetragen ist, zeigen wir "--:--"
        const displayTime = item.time === '00:00' ? '--:--' : item.time;
        
        let detailsHTML = '';
        if(item.location) detailsHTML += `<div style="margin-top:4px">üìç ${item.location}</div>`;
        if(item.note) detailsHTML += `<div style="margin-top:4px; font-style:italic; opacity:0.8">" ${item.note} "</div>`;
        if(!item.location && !item.note) detailsHTML += `<div style="margin-top:4px; opacity:0.5; font-size:11px">Keine Details</div>`;

        row.innerHTML = `
            <div class="today-time-col">
                <div class="today-time-text">${displayTime}</div>
                <div class="today-line"></div>
            </div>
            <div class="today-bubble" onclick="safeRun(openDetail, ${item.animalIdx})">
                <div class="today-header">
                    <div class="today-animal-name">${item.emoji} ${item.name}</div>
                    <span style="font-size:12px; color:var(--accent)">‚ûî</span>
                </div>
                <div class="today-details">
                    ${detailsHTML}
                </div>
            </div>
        `;
        listCont.appendChild(row);
    });

    // Letzte Linie ausblenden (kosmetisch)
    if(listCont.lastChild) {
        listCont.lastChild.querySelector('.today-line').style.background = 'transparent';
    }

    getEl('todayModal').style.display = 'block';
}

// --- NEUE FUNKTION: Akkordeon umschalten ---
function toggleAccordion(headerElement) {
    // Wir klicken auf den Header, wollen aber die ganze Sektion √∂ffnen
    const section = headerElement.closest('.card-section');
    section.classList.toggle('open');
}
// WICHTIG: Inputs innerhalb des Akkordeons d√ºrfen das Zuklappen nicht ausl√∂sen.
// Das habe ich im HTML oben schon mit onclick="event.stopPropagation()" gel√∂st.


// === QUICK SIGHTING LOGIC ===
let isQuickSightingMode = false;

/* === ERSETZE DIE BESTEHENDE openQuickSighting FUNKTION HIERMIT: === */

function openQuickSighting() {
    isQuickSightingMode = true;
    const modal = getEl('noteModal');
    
    // UI Reset
    getEl('noteModalTitle').innerText = "‚ûï Neue Sichtung";
    getEl('noteAnimalWrapper').style.display = 'block'; 
    getEl('noteAnimalInput').value = '';
    getEl('noteAnimalResults').style.display = 'none';
    getEl('noteDate').value = todayStr(); 
    getEl('noteTime').value = nowTimeStr();
    getEl('noteText').value = '';
    getEl('noteLoc').value = '';
    
    // Fokus aufs Eingabefeld (kleiner Timeout hilft bei Mobile)
    setTimeout(() => getEl('noteAnimalInput').focus(), 100);
    
    setupLocationAutocomplete();

    // Autocomplete Logik (Kurzfassung)
    const inp = getEl('noteAnimalInput');
    inp.oninput = (e) => {
        const val = e.target.value.toLowerCase();
        const res = getEl('noteAnimalResults');
        res.innerHTML = '';
        if(val.length < 1) { res.style.display='none'; return; }
        const matches = animals.filter(a => a.name.toLowerCase().includes(val));
        if(matches.length > 0) {
            res.style.display = 'block';
            matches.slice(0, 5).forEach(a => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.innerHTML = `${a.emoji} <b>${a.name}</b>`;
                div.onclick = () => { inp.value = a.name; res.style.display = 'none'; };
                res.appendChild(div);
            });
        } else { res.style.display = 'none'; }
    };

    // === HIER IST DIE NEUE LOGIK ===
    getEl('noteSaveBtn').onclick = () => {
        const animalName = getEl('noteAnimalInput').value.trim();
        if(!animalName) return showErrorToast("Bitte Tiernamen eingeben");

        let idx = animals.findIndex(a => a.name.toLowerCase() === animalName.toLowerCase());
        let isNewAnimal = false;

        // Wenn Tier neu ist -> Anlegen
        if(idx === -1) {
            animals.push({ name: animalName, emoji: 'üêæ', imageId: null, tags: [], isFav: false });
            idx = animals.length - 1;
            saveGlobals();
            isNewAnimal = true; // Flag setzen!
        }

        // Ort speichern (falls neu)
        const rawLoc = getEl('noteLoc').value.trim();
        if(rawLoc && !locations.includes(rawLoc)) {
            locations.push(rawLoc);
            saveGlobals();
            if(typeof renderLocations === 'function') renderLocations();
        }

        // Eintrag schreiben
        const d = getEl('noteDate').value || todayStr();
        const data = { 
            time: getEl('noteTime').value, 
            location: rawLoc, 
            note: getEl('noteText').value 
        };
        
        playSound('pop');
        writeEntry(d, idx, data);
        
        // ZUERST Notiz-Modal schlie√üen
        closeModal('noteModal');
        render();

        // ENTSCHEIDUNG: War es neu? Dann sofort Edit √∂ffnen!
        if (isNewAnimal) {
            setTimeout(() => {
                showErrorToast("‚ú® Neu! W√§hle jetzt ein Icon/Bild.", true);
                openIconEdit(idx); // √ñffnet das Bearbeiten-Fenster f√ºr das neue Tier
            }, 300); // 300ms warten, damit die Modals nicht "kollidieren"
        } else {
            showErrorToast("Sichtung gespeichert!", true);
        }
    };

    modal.style.display = 'block';
}

/* === TUTORIAL LOGIC === */
let currentStep = 0;
const tourSteps = [
    { target: null, title: "Willkommen! üëã", text: "Sch√∂n, dass du da bist! <b>Tier Ticker</b> ist dein Begleiter f√ºr die Natur.<br><br>Ich zeige dir kurz die wichtigsten Funktionen." },
    { target: '.btn-sighting-large', title: "Schnell-Sichtung", text: "Tippe hier, um sofort ein Tier zu notieren. Du kannst weitere Details hinzuf√ºgen." },
    { target: '#listSearch', title: "Suche & Filter", text: "Finde Tiere schnell wieder oder filtere nach Kategorien (z.B. V√∂gel)." },
    { target: '.bottom-nav', title: "Alles im Griff", text: "Hier wechselst du zwischen Liste, Karte, Statistik und Einstellungen." },
    { target: '.icon-btn-header.info', title: "Hilfe & Infos", text: "Hier findest du dieses Tutorial jederzeit wieder!" }
];

function startTutorial(force = false) {
    if (!force && localStorage.getItem('tutorial_done') === 'true') return;
    document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
    window.scrollTo({top: 0, behavior: 'smooth'});
    currentStep = 0;
    
    // UI anzeigen
    document.getElementById('onboardingOverlay').style.display = 'block';
    document.getElementById('onboardingBubble').style.display = 'block';
    
    setTimeout(() => { showStep(0); }, 100);
}

function showStep(index) {
    if (index >= tourSteps.length) { endTutorial(true); return; }
    const step = tourSteps[index];
    const bubble = document.getElementById('onboardingBubble');
    const overlay = document.getElementById('onboardingOverlay');
    
    // Texte
    document.getElementById('tourTitle').innerText = step.title;
    document.getElementById('tourText').innerHTML = step.text;
    document.getElementById('tourNextBtn').innerText = index === tourSteps.length - 1 ? "Fertig üöÄ" : "Weiter ‚ûî";

    // Clean up
    document.querySelectorAll('.tour-highlight').forEach(el => el.classList.remove('tour-highlight'));

    if (step.target) {
        const el = document.querySelector(step.target);
        if (el) {
            el.scrollIntoView({behavior: 'smooth', block: 'center'});
            el.classList.add('tour-highlight');
            
            // Wenn Ziel da ist: Overlay transparent, Schatten macht die Arbeit
            overlay.style.background = 'transparent';

            // Bubble Position
            const rect = el.getBoundingClientRect();
            bubble.style.top = "auto"; bubble.style.bottom = "auto"; 
            bubble.style.left = "50%"; bubble.style.transform = "translateX(-50%)";

            if (rect.top < window.innerHeight / 2) {
                let topPos = rect.bottom + 20;
                if(topPos > window.innerHeight - 200) topPos = window.innerHeight - 220; 
                bubble.style.top = topPos + "px";
            } else {
                let botPos = (window.innerHeight - rect.top) + 20;
                bubble.style.bottom = botPos + "px";
            }
        }
    } else {
        // Start: Overlay dunkel machen (weil kein Element Schatten wirft)
        overlay.style.background = 'rgba(0, 0, 0, 0.85)';
        bubble.style.top = "50%"; bubble.style.left = "50%"; 
        bubble.style.transform = "translate(-50%, -50%)";
    }
}

function nextStep() { currentStep++; showStep(currentStep); }

function endTutorial(completed = false) {
    document.getElementById('onboardingOverlay').style.display = 'none';
    document.getElementById('onboardingBubble').style.display = 'none';
    document.querySelectorAll('.tour-highlight').forEach(el => el.classList.remove('tour-highlight'));
    if (completed) {
        localStorage.setItem('tutorial_done', 'true');
        showErrorToast("Viel Spa√ü! üêæ", true);
        if(typeof playSound === 'function') playSound('fanfare');
    }
}

/* === CONTEXT MENU LOGIC (DAS HAT GEFEHLT) === */

// 1. Das Men√º zeichnen
// 1. Das Men√º zeichnen
function openContextMenu(x, y, items) {
    // Alte Men√ºs entfernen
    closeContextMenu();

    // Backdrop (damit Klick daneben es schlie√üt)
    const backdrop = document.createElement('div');
    backdrop.className = 'context-backdrop';
    backdrop.onclick = closeContextMenu;
    document.body.appendChild(backdrop);

    // Men√º Container
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    
    // REPARATUR: Smarte Positionierung
    const winW = window.innerWidth;
    const menuWidth = 190; // Gesch√§tzte Breite
    
    // Wenn Men√º rechts rausragt, nach links schieben
    if (x + menuWidth > winW) {
        x = winW - menuWidth - 10; 
    }
    // Wenn Men√º links rausragt (negative x), auf 10px setzen
    if (x < 10) x = 10;
    
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    // Items generieren
    items.forEach(item => {
        const div = document.createElement('div');
        div.className = `context-item ${item.danger ? 'danger' : ''}`;
        div.innerHTML = `<span style="font-size:18px">${item.icon}</span> ${item.label}`;
        div.onclick = () => {
            closeContextMenu();
            // Die Aktion ausf√ºhren
            safeRun(() => { eval(item.action); }); 
        };
        menu.appendChild(div);
    });

    document.body.appendChild(menu);
    
    // Kleines Vibrations-Feedback
    if(navigator.vibrate) navigator.vibrate(5);
}


function closeContextMenu() {
    document.querySelectorAll('.context-menu, .context-backdrop').forEach(e => e.remove());
}

// 2. Das Men√º f√ºr die LISTE (Startseite)

// 2. Das Men√º f√ºr die LISTE (Startseite)
function openItemMenu(idx, event) {
    if(event) event.stopPropagation();
    
    // Koordinaten holen
    let x = event.clientX || (event.touches ? event.touches[0].clientX : 0);
    let y = event.clientY || (event.touches ? event.touches[0].clientY : 0);

    // HIER GE√ÑNDERT: Miniatur-Version des "Sichtung Buttons" (Viereck)
    const btnStyleIcon = `<span style="display:inline-flex; align-items:center; justify-content:center; background:var(--accent); color:white; border-radius:8px; width:26px; height:26px; font-size:18px; font-weight:900; box-shadow:0 2px 5px var(--accent-glow); padding-bottom:1px;">+</span>`;

    const items = [
        { label: 'Tier bearbeiten', icon: '‚úèÔ∏è', action: `openIconEdit(${idx})` },
        
        // Hier das neue Icon einf√ºgen
        { label: 'Sichtung', icon: btnStyleIcon, action: `openNoteModal(${idx})` },
        
        { label: 'In Papierkorb', icon: 'üóëÔ∏è', action: `moveToTrash(${idx})`, danger: true }
    ];

    openContextMenu(x, y, items);
}

// 3. Das Men√º f√ºr das DETAIL-HEADER (Tier selbst)

// 3. Das Men√º f√ºr das DETAIL-HEADER (Tier selbst)
function openAnimalMenu(idx, event) {
    if(event) event.stopPropagation(); // Verhindert Bubbling
    
    // Button Position finden
    const rect = event.target.getBoundingClientRect();
    
    // REPARATUR: Sicherstellen, dass x nicht negativ wird oder zu weit rechts ist
    // Wir zielen auf "links vom Button", aber min. 10px vom Rand
    let x = rect.left - 140; 
    if (x < 10) x = 10; // Nicht links rausfliegen
    
    const y = rect.bottom + 5;

    const items = [
        { label: 'Tier bearbeiten', icon: '‚úèÔ∏è', action: `openIconEdit(${idx})` },
        { label: 'Tier l√∂schen', icon: 'üóëÔ∏è', action: `moveToTrash(${idx})`, danger: true }
    ];

    openContextMenu(x, y, items);
}

// Zeigt Details unter der Heatmap an
function showHeatmapInfo(el, dateStr, count) {
    // 1. Text aktualisieren
    const infoBox = document.getElementById('heatmapInfoText');
    if(count === 0) infoBox.innerText = `${dateStr}: Keine Sichtungen`;
    else infoBox.innerText = `${dateStr}: ${count} Tier${count!==1?'e':''} entdeckt!`;
    
    // 2. Visuelles Feedback (Active State f√ºr alle anderen entfernen)
    document.querySelectorAll('.heat-cell.selected').forEach(c => c.classList.remove('selected'));
    el.classList.add('selected');
}

function animateValue(obj, start, end, duration) {
    if(!obj) return;
    let startTimestamp = null;
    const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        obj.innerHTML = Math.floor(progress * (end - start) + start);
        if (progress < 1) {
            window.requestAnimationFrame(step);
        }
    };
    window.requestAnimationFrame(step);
}

/* === LISTE EIN- UND AUSKLAPPEN STEUERUNG === */

function expandList() {
    listExpanded = true;
    render(); // <--- WICHTIG: Sofort neu zeichnen!
    
    // Haptisches Feedback (optional)
    if(navigator.vibrate) navigator.vibrate(10);
}

function collapseList() {
    listExpanded = false;
    render(); // <--- WICHTIG: Sofort neu zeichnen!
    
    // Nach dem Einklappen wieder sanft zum Anfang der Liste scrollen
    // damit man nicht "im Nichts" steht, wenn die Liste kurz wird.
    const container = document.getElementById('sneakPeekContainer');
    if(container) {
        container.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}
/* Helper f√ºr das neue Widget */
function switchStat(id) {
    // 1. Alle ausblenden
    document.querySelectorAll('.stat-content').forEach(el => el.classList.remove('active'));
    // 2. Gew√§hlten einblenden
    const target = document.getElementById(id);
    if(target) target.classList.add('active');
}

/* Helper f√ºr den Verlauf Toggle */
function toggleHistory(btn) {
    // 1. Button Status toggeln (Pfeil drehen)
    btn.classList.toggle('open');
    
    // 2. Den Wrapper finden (n√§chstes Element)
    const wrapper = btn.nextElementSibling;
    
    // 3. Wrapper √∂ffnen/schlie√üen
    wrapper.classList.toggle('open');
    
    // Optional: Wenn ge√∂ffnet, kurz warten und hinscrollen
    if(wrapper.classList.contains('open')) {
        setTimeout(() => {
            wrapper.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 200);
    }
}

/* === MAP BOTTOM SHEET LOGIC === */

function openMapSheet(locationName, count) {
    // 1. Daten in das HTML schreiben
    getEl('sheetTitle').innerText = locationName;
    getEl('sheetSub').innerText = `${count} Sichtungen an diesem Ort`;
    
    // 2. Den "Pfeil"-Button konfigurieren
    const btn = getEl('sheetJumpBtn');
    btn.onclick = () => jumpToLocationFilter(locationName);
    
    // 3. Sheet hochfahren
    getEl('mapSheet').classList.add('active');
    
    // Kleines Vibrations-Feedback
    if(navigator.vibrate) navigator.vibrate(5);
}

function jumpToLocationFilter(locationName) {
    // 1. Sheet schlie√üen
    getEl('mapSheet').classList.remove('active');
    
    // 2. Suchleiste f√ºllen (Das ist der Trick!)
    const searchInput = getEl('listSearch');
    searchInput.value = locationName;
    
    // 3. Zur Liste wechseln
    // Wir simulieren einen Klick auf den ersten Nav-Button ("Liste")
    const listNavBtn = document.querySelectorAll('.nav-item')[0];
    switchView('view-list', listNavBtn);
    
    // 4. Liste neu rendern (filtert automatisch nach dem Ort im Suchfeld)
    render();
    
    // 5. User Feedback
    showErrorToast(`Zeige Tiere in: ${locationName}`, true);
}

/* === MEMORY DECK LOGIC === */
let deckCards = [];

async function initMemoryDeck() {
    const wrapper = document.getElementById('memoryDeckWrapper');
    const container = document.getElementById('cardDeck');
    if(!wrapper || !container) return;

    // 1. Alle interessanten Eintr√§ge sammeln
    let candidates = [];
    const years = getAvailableYears();
    
    years.forEach(y => {
        const h = getHistory(y);
        Object.values(h).forEach(d => {
            if(d.perAnimal) {
                Object.entries(d.perAnimal).forEach(([idxStr, list]) => {
                    const idx = parseInt(idxStr);
                    const animal = animals[idx];
                    if(!animal) return;
                     // Datum sch√∂n formatieren (von YYYY-MM-DD zu DD.MM.YYYY)
                    const [yStr, mStr, dStr] = d.date.split('-');
                    const dateFormatted = `${dStr}.${mStr}.${yStr}`;
                   
                    list.forEach(entry => {
                        // Priorisiere Eintr√§ge mit Bild (vom Tier) oder Notiz
                        if(entry.note || animal.imageId) {
                      candidates.push({
                      animalIdx: idx,
                      name: animal.name,
                      emoji: animal.emoji,
                      // HIER NEU: Datum und Zeit getrennt speichern
                      dateDisplay: dateFormatted,
                      timeDisplay: entry.time ? `${entry.time} Uhr` : '--:--', 
                      note: entry.note || "Ein sch√∂ner Moment.",
                      loc: entry.location || "Unbekannt",
                      imageId: animal.imageId
                        });
                        }
                    });
                });
            }
        });
    });

    // Wenn zu wenig da ist, gar nicht anzeigen
    if(candidates.length < 3) {
        wrapper.style.display = 'none';
        return;
    }

    // 2. Zuf√§llige 5 ausw√§hlen (Shuffle)
    candidates.sort(() => 0.5 - Math.random());
    const selection = candidates.slice(0, 5);

    // 3. Karten bauen
    // Erst leeren (au√üer empty state div)
    const emptyState = container.querySelector('.deck-empty');
    container.innerHTML = '';
    container.appendChild(emptyState);
    deckCards = [];

    wrapper.style.display = 'block';

    // Async Loop um Bilder zu laden
    for (let i = 0; i < selection.length; i++) {
        const item = selection[i];
        
        const el = document.createElement('div');
        el.className = 'deck-card';
        // Z-Index: Erste Karte (i=0) muss ganz oben sein (h√∂chster Index)
        // Aber warte: Im Stapel ist das letzte Element im DOM ganz oben.
        // Wir f√ºgen sie nacheinander an, also ist das letzte selection-Item oben.
        // Damit es logisch passt, iterieren wir r√ºckw√§rts oder passen z-index an.
        // Besser: Wir h√§ngen an, das letzte ist oben.
        
        let imgSrc = '';
        if(item.imageId) {
            try { imgSrc = await dbGetImg(item.imageId); } catch(e){}
        }
        
        // Fallback Bild oder Farbe wenn kein Bild
        const imgHTML = imgSrc 
            ? `<img src="${imgSrc}" class="dc-img">` 
            : `<div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size:60px; background:var(--bg);">${item.emoji}</div>`;

        // Format Date
        const niceDate = item.fullDate ? item.fullDate.split('-').reverse().slice(0,2).join('.') + "." : item.date;


       el.innerHTML = `
    <div class="dc-img-area">
        ${imgHTML}
        <div class="dc-overlay"></div>
        <div class="dc-badge">üìç ${item.loc}</div>
    </div>
    <div class="dc-body">
        <div class="dc-title">${item.emoji} ${item.name}</div>
        <div class="dc-note">"${item.note}"</div>
        
        <!-- HIER NEU: Datum und Zeit getrennt -->
        <div class="dc-date">
            <span>üìÖ ${item.dateDisplay}</span>
            <span>‚åö ${item.timeDisplay}</span>
        </div>
    </div>
`;
              
        container.appendChild(el);
        deckCards.push(el); // Array zum Verwalten
        
        // Physik hinzuf√ºgen
        makeCardDraggable(el);
    }
    
    updateDeckVisuals();
}

function updateDeckVisuals() {
    // Die Karten liegen im DOM √ºbereinander. 
    // Wir wollen aber das Array 'deckCards' von vorne abarbeiten (Shift).
    // Momentan: container.appendChild f√ºgt unten an -> das ist im Stapel OBEN.
    // Also ist die LETZTE Karte im Array die oberste visuell.
    
    // Wir √§ndern die Logik: Wir behandeln index 0 als "ganz oben".
    // Dazu m√ºssen wir z-index manuell setzen.
    
    deckCards.forEach((card, i) => {
        const revIdx = i; // 0 ist die vorderste
        
        card.style.zIndex = deckCards.length - i;
        
        if (i === 0) {
            // Oberste Karte
            card.style.transform = 'scale(1) translateY(0) rotate(0deg)';
            card.style.opacity = '1';
            card.style.filter = 'brightness(1)';
            card.style.pointerEvents = 'all';
        } else if (i === 1) {
            // Zweite
            card.style.transform = 'scale(0.95) translateY(15px) rotate(-2deg)';
            card.style.opacity = '1';
            card.style.filter = 'brightness(0.8)';
            card.style.pointerEvents = 'none';
        } else if (i === 2) {
            // Dritte
            card.style.transform = 'scale(0.9) translateY(30px) rotate(2deg)';
            card.style.opacity = '0.5';
            card.style.filter = 'brightness(0.6)';
            card.style.pointerEvents = 'none';
        } else {
            // Rest versteckt
            card.style.opacity = '0';
            card.style.transform = 'scale(0.8) translateY(50px)';
            card.style.pointerEvents = 'none';
        }
    });
}

function makeCardDraggable(card) {
    let startX = 0, currentX = 0, isDragging = false;
    
    const start = (e) => {
        // Nur wenn es die oberste Karte ist
        if(card !== deckCards[0]) return;
        
        isDragging = true;
        startX = e.clientX || e.touches[0].clientX;
        card.style.transition = 'none'; // Direktes Feedback
    };
    
    const move = (e) => {
        if(!isDragging) return;
        // Scrollen verhindern auf Mobile beim Wischen
        // (Optional: nur wenn Bewegung horizontal ist)
        
        const clientX = e.clientX || e.touches[0].clientX;
        currentX = clientX - startX;
        
        // Rotation
        const rot = currentX * 0.05;
        card.style.transform = `translateX(${currentX}px) rotate(${rot}deg)`;
    }
    
    const end = (e) => {
        if(!isDragging) return;
        isDragging = false;
        
        // Schwelle zum Wegwerfen
        if(Math.abs(currentX) > 100) {
            // Wegwerfen
            const dir = currentX > 0 ? 1 : -1;
            const endX = window.innerWidth; // Weit weg
            
            card.classList.add('is-flying');
            card.style.transform = `translateX(${dir * endX}px) rotate(${dir * 30}deg)`;
            
            setTimeout(() => {
                card.remove(); // Aus DOM
                deckCards.shift(); // Aus Array (erstes Element weg)
                updateDeckVisuals(); // Nachr√ºcker stylen
            }, 300);
            
            // Haptic
            if(navigator.vibrate) navigator.vibrate(10);
            
        } else {
            // Reset (Zur√ºckfedern)
            card.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            card.style.transform = 'scale(1) translateY(0) rotate(0deg)';
        }
        currentX = 0;
    }
    
    card.addEventListener('mousedown', start);
    card.addEventListener('touchstart', start, {passive: true});
    
    document.addEventListener('mousemove', move);
    document.addEventListener('touchmove', move, {passive: false}); // passive: false wichtig f√ºr preventDefault falls n√∂tig
    
    document.addEventListener('mouseup', end);
    document.addEventListener('touchend', end);
}


// Neuer Helper f√ºr das Modal
function openInfoModal() {
    getEl('infoModal').style.display = 'block';
}



// Start-Check
setTimeout(() => { startTutorial(); }, 1500);

// STARTUP
loadGlobals(); render(); initSwipeGestures();


</script>
</body>
</html>
